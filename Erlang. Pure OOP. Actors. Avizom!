
alexelizarov [8:55 AM] 
Помогите пожалуйста разобраться. В Википедии написано про лямбда-исчисление:   ​*λ-исчисление может рассматриваться как семейство прототипных языков программирования*​. И после этого написано еще:   ​*Тем самым обеспечивается систематический подход к исследованию операторов, аргументами которых могут быть другие операторы, а значением также может быть оператор. Языки в этом семействе являются функциональными.*​ То есть из этого я делаю вывод, что языки в семействе прототипных являются функциональными. Но дальше открываю страничку в той же Википедии про прототипные языки:   ​*Прототипное программирование — стиль объектно-ориентированного программирования, при котором отсутствует понятие класса, а наследование производится путём клонирования существующего экземпляра объекта — прототипа.*​ Как же так? Объектно ориентированные, но при этом функциональные?(edited)

kirill.mokevnin [8:57 AM] 
у вас тут неправильный переход получился

alexelizarov [8:58 AM] 
А как правильно?

kirill.mokevnin [9:03 AM] 
честно говоря, я не знаю что имел ввиду автор той статьи в вики про лямбда исчисление

[9:03] 
не обращайте на эту фразу внимания, она только с толку сбивает

alexelizarov [9:08 AM] 
@kirill.mokevnin: это вы про фразу что лямбда-исчисление может рассматриваться как семейство прототипных языков программирования?

kirill.mokevnin [9:08 AM] 
да

[9:08] 
это уже фантазия автора, лямбда исчисление это формальная система, вот от этого надо прыгать

[9:09] 
Lambda calculus (also written as λ-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution. It was first introduced by mathematician Alonzo Church in the 1930s as part of an investigation into the foundations of mathematics. Lambda calculus is a universal model of computation equivalent to a Turing machine (Church-Turing thesis, 1937[1]).

alexelizarov [9:17 AM] 
Ну да, вот это менее противоречиво по-моему) Еще спрошу, раз уж наткнулся на статью о прототипном программировании. В СИКП во второй главе упоминается такой прием программирования как "обмен сообщениями". Это как то связано с прототипным программированием, да? Там ведь появляется уже что то похожее на объекты, хотя никаких классов нет. И в прототипном программировании так же. Хотя наверное я не прав, потому что это уже объктно-ориентированное программирование, хоть и не самый привычный его вариант. А Sheme ведь не поддерживает объектно-ориентированную парадигму ни в каком виде?

kirill.mokevnin [9:19 AM] 
никак не связано

[9:20] 
вам важно понять что ооп это не парадигма

[9:20] 
мы тут каждый раз об этом говорим

alexelizarov [9:20 AM] 
да, поторопился написать) ООП это разновидность императивной парадигмы

kirill.mokevnin [9:21 AM] 
на том уровне на котором существует лямбда исчисление, существует императивный подход

[9:21] 
объекты это про состояние

[9:22] 
обмен сообщениями это про late binding

alexelizarov [9:25 AM] 
а функциональные языки другими способами позволяют управлять состоянием?  Даже когда там появляется состоянием, то ООП там нет ни в каком виде?

kirill.mokevnin [9:25 AM] 
что вы имеете ввиду под ооп?

alexelizarov [9:27 AM] 
Разновидность итеративной парадигмы, которая предоставляет удобные инструменты для управление состоянием

kirill.mokevnin [9:28 AM] 
слово “удобные” в определении это как-то странновато)

alexelizarov [9:28 AM] 
Ну это я имею в виду что удобнее чем в процедурном подходе

kirill.mokevnin [9:28 AM] 
настолько удобные что с использованием этого ооп невозможно писать паралелльный код?

[9:29] 
ну формально определять что то через противопоставление это тоже не вариант

[9:29] 
вон го появился

[9:29] 
почему все рванули на язык на котором нет “удобных инструментов дя управления состоянием"

[9:29] 
снова вернулись в процедурщину

alexelizarov [9:30 AM] 
У меня наверное совсем дилетантский уровень, но я не понимаю какой язык вы имеете в виду(

kirill.mokevnin [9:30 AM] 
golang

[9:31] 
модный  молодежный современный
2  

alexelizarov [9:32 AM] 
И почему же так происходит? Почему возвращаются к процедурщине? Что же, все то время когда ООП был так популярен (лет 30 наверное?) да и сейчас остается популярен все заблуждались на его счет?(edited)

kirill.mokevnin [9:33 AM] 
потому что на самом деле этого всего лишь один из способов представлять код

[9:34] 
программирование это не ооп

[9:34] 
это строительство абстракций, управление состоянием

[9:34] 
системы типов

alexelizarov [9:36 AM] 
А вот erlang, например? Это же функциональный язык? Как он позволяет управлять состоянием? Там ведь вроде есть объекты, которые обмениваются сообщениями?

kirill.mokevnin [9:37 AM] 
да

[9:38] 
с точки зрения отца основателя термина ооп, это самый настоящий ооп язык :wink:

[9:38] 
в эрланге сделали гениальную вещь

[9:38] 
щас покажу

[9:39] 
понять это в тыщу раз проще чем какое нибудь ооп в php

[9:39] 
нас еще кто нибудь смотрит?)
10  

[9:40] 
6> self().
<0.41.0>

[9:40] 
в эрланге есть self

[9:40] 
который показывает id текущего объекта

[9:40] 
объект в эрланге это процесс

[9:40] 
или актор

[9:40] 
с точки зрения модели акторов

[9:40] 
процессом он называется потому что не шарит ни с кем состояние

[9:40] 
как настоящие процессы в операционных системах

[9:40] 
у них независимая память

[9:41] 
а значит что они абсолютно спокойно и безопасно работают паралелльно

[9:41] 
что совсем не так в "ооп"(edited)

[9:41] 
вот эту проблему надо четко осознать

[9:41] 
вы знаете в чем проблема с паралелльностью в коде где данные шарятся?

john_mephistophilus [9:41 AM] 
отслеживание кучи состояний

kirill.mokevnin [9:41 AM] 
представьте что у вас два потока, и один общий объект на двоих

alexelizarov [9:42 AM] 
В том что может начаться состояние гонки?

kirill.mokevnin [9:42 AM] 
и есть код типа if obj.can_update? obj.lala =‘ehu'

[9:42] 
этот код не атомарен

[9:42] 
у вас может одновременно провериться if

[9:42] 
и два потока войдут внутрь условия

[9:42] 
хотя подразумевалось что только один туда может войти

[9:43] 
все это работает в одном потоке

[9:43] 
но любая параллелизация приводит к жопе сразу

[9:43] 
и начинаются гонки

[9:43] 
и что сюда врывается когда начинаются гонки?

john_mephistophilus [9:43 AM] 
дедлоки?

alexelizarov [9:43 AM] 
дедлоки

vgv [9:44 AM] 
Не дедлоки.

alexelizarov [9:45 AM] 
Синхронизация?

kirill.mokevnin [9:45 AM] 
примитивы синхронизации

[9:45] 
и понеслась семафоры мониторы

alexelizarov [9:46 AM] 
А в функциональных языках можно не париться насчет синхронизации и все равно не иметь проблем, описанных выше?

kirill.mokevnin [9:46 AM] 
@vgv в java же можно метод объявить synhronize?

[9:46] 
аннотацию

vgv [9:46 AM] 
Да

kirill.mokevnin [9:46 AM] 
и типа метод атомарен стал?

vgv [9:46 AM] 
Это классический мьютекс

kirill.mokevnin [9:46 AM] 
понял(edited)

vgv [9:47 AM] 
На уровне языка и со всеми плюсами/минусами что из этого вытекают

kirill.mokevnin [9:47 AM] 
а еще есть какие штуки высокоуровневые в яве?

vgv [9:47 AM] 
Ну, высокоуровневыми ключевые слова synchronized/volatile сложно назвать

[9:47] 
Причем заметьте - это прямо ​*ключевые слова*​ в языке )

kirill.mokevnin [9:48 AM] 
ну и да, это не проблема самой ооп, это проблема изменяемого состояния, то есть императивного подхода

[9:48] 
соответственно все это распостраняется на то что поверх императивщины построено

vgv [9:48 AM] 
Но есть еще более гибкие классы/подходы которые позволяют использовать современные возможности процессоров, а конкретно - CAS

[9:48] 
compare-and-set

kirill.mokevnin [9:48 AM] 
и вы ничего с этим не сделаете, оно так в железе

[9:48] 
поэтому жизнь боль всегда для тех кто пишет компиляторы

[9:48] 
чтобы там наверху не было

[9:50] 
ага, аппаратно вот пытаются решить

[9:50] 
я читал раньше что довольно много сейчас там таких возможностей

[9:50] 
так вот поехали дальше

[9:50] 
про процессы

[9:50] 
процессы не шарят память, соответственно у них нет проблем с паралелльностью

[9:50] 
другое дело дедлоки, но это отдельная история

[9:51] 
а как тогда процессам обменивать данными?

alexelizarov [9:52 AM] 
Отправлять друг другу сообщения?

robot_den [9:52 AM] 
воздействовать на еще какой нибудь "контрольный" процесс ?

kirill.mokevnin [9:54 AM] 
так)

[9:54] 
https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BD%D0%BE%D0%B5_%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5

[9:54] 
это вы должны знать как разработчики

[9:55] 
грубо говоря все это сводится к тому что операционка копирует из адресного пространства одного процесса в другой

[9:55] 
возможно копирует это “копирует” потому что есть всякие copy-on-write техники для оптимизации

[9:55] 
но это уже тонкости

[9:56] 
так вот в эрланге процессы обмениваются сообщениями

[9:56] 
любое место в эрланге это процесс

[9:56] 
так же как в операционке

[9:56] 
вы не можете находится где то снаружи во вселенной(edited)

[9:56] 
вы всегда внутри процесса(edited)

[9:56] 
так же как и в ОС

[9:56] 
этот момент понятен?

akasstalkalex [9:57 AM] 
вполне

kirill.mokevnin [9:58 AM] 
```Eshell V7.1  (abort with ^G)
1> self().
<0.34.0>
2> self() ! "hello, world".
"hello, world"
3> flush().
Shell got "hello, world"
ok
4> crash().
** exception error: undefined shell command crash/0
5> self().
<0.39.0>
```

alexelizarov [9:58 AM] 
То есть в erlang, под капотом остаются все эти проблемы с семафорами и так далее? Просто они предоставили такие высокоуровневые абстракции что программисты на erlang могут об этом не беспокоиться?

kirill.mokevnin [9:58 AM] 
это проблемы физического мира, от них нельзя уйти

[9:58] 
любой фп язык потом на процессоре выполняется

[9:59] 
просто представьте что у вас в система два паралелльных процессора

[9:59] 
вам нужны локи чтобы контролировать процесс

[9:59] 
иначе будет ахтунг

[10:00] 
ну и в этом суть абстракций

[10:00] 
давайте по коду выше

[10:00] 
что не понятно?

[10:00] 
и самый интересный вопрос, что произошло в конце

akasstalkalex [10:01 AM] 
другой процесс ответил?

alexelizarov [10:02 AM] 
даже не представляю(

kirill.mokevnin [10:02 AM] 
давайте по порядку

[10:02] 
что происходит

alexelizarov [10:02 AM] 
self() это объект?

kirill.mokevnin [10:02 AM] 
это вызов метода

[10:02] 
внезапно да?)

[10:02] 
это же фп язык, тут все деревянное

alexelizarov [10:03 AM] 
да уж) вызов метода без объекта)

kirill.mokevnin [10:03 AM] 
ой, функции

akasstalkalex [10:03 AM] 
возвращает пид процесса, в котором функция эта выполняется

kirill.mokevnin [10:03 AM] 
на самом деле если я говорю метод, я оговариваюсь

[10:03] 
да, она просто pid процесса текущего возвращает

[10:03] 
причем pid это прямо тип данных

[10:03] 
а не просто число

[10:04] 
`!` - вот это специальный оператор, слева ожидается пид, справа мессадж

[10:04] 
то есть мы послали сообщение в процесс

[10:05] 
в данном случае сами себе

[10:05] 
почему нет

[10:05] 
эрланг позволяет слать мессаджи процессам которые находятся физически на других машинах

[10:05] 
так называемый распределенный эрланг

alexelizarov [10:05 AM] 
А можно было бы еще указать в какой процесс посылаем?

kirill.mokevnin [10:05 AM] 
“какой процесс” это и есть PID

alexelizarov [10:05 AM] 
из какого, что и в какой?

kirill.mokevnin [10:06 AM] 
все что угодно

[10:06] 
pid ! <все что угодно>

[10:06] 
pid ! {self(), save_to_db, User}(edited)

[10:06] 
пожалуйста

[10:06] 
save_to_db - в данном случае это атом

[10:06] 
атомы это как символы в руби

[10:07] 
строка без кавычек грубо говоря

[10:07] 
User - это какая то структура данных которая юзера означает

[10:07] 
{} - это кортеж

[10:08] 
грубо говоря похоже на массив, но неизменяемый, вы один раз создали его, и дальше можете только читать

[10:08] 
конечно это не массив, но ближе аналогию сложно найти

[10:08] 
{one, two, three} - кортеж из трех элементов

[10:09] 
теперь вопрос, вот у вас есть процесс который обрабатывает входящие сообщения

[10:09] 
и делает он это скажем долго

[10:09] 
а сообщения в него сыпятся быстро

[10:09] 
что происходит с сообщениями которые он прямо щас не может взять в обработку?

alexelizarov [10:09 AM] 
в очередь выстраиваются?

[10:09] 
или он их пересылает другому?

kirill.mokevnin [10:10 AM] 
все правильно, у каждого процесса есть mailbox

[10:10] 
все сообщения складываются туда

[10:10] 
процесс шела выше никак не обрабатывает сообщения

igrishaev [10:10 AM] 
Извините что влезаю. Эта цитата из вики, с которой все и началось
> λ-исчисление может рассматриваться как семейство прототипных языков программирования*​.
очень странная. Во-первых, там звездочка, во-вторых, определение очень кривое. Может рассматриваться, может и нет. Если вы заинтересовались лямбда-ичислениями, прототипное программирование пока лучше не трогать. Я не вижу явной связи между ними.

kirill.mokevnin [10:10 AM] 
поэтому они просто складываются в инбокс

[10:11] 
ага, я тоже ее не понял)

[10:11] 
3> flush().

[10:11] 
думаю тут должно быть понято

[10:11] 
эта штука просто сбрасывает сообщения

alexelizarov [10:11 AM] 
@igrishaev:  спасибо)(edited)

kirill.mokevnin [10:11 AM] 
и шел печатает на экран их

[10:12] 
а вот что эт

[10:12] 
4> crash().
** exception error: undefined shell command crash/0
5> self().
<0.39.0>

alexelizarov [10:12 AM] 
нет такого метода crash()?

kirill.mokevnin [10:12 AM] 
нет

akasstalkalex [10:12 AM] 
выбросили эксепшн, а след. функция ответила уже из друго процесса

kirill.mokevnin [10:13 AM] 
процесс умер

[10:13] 
а дальше его перезапустили (кто и как это отдельная история)

[10:13] 
и self() теперь говорит что мы внутри другого процесса

[10:13] 
теперь вы можете представить себе программирование на эрланг

[10:14] 
множество процессов (они же объекты потому что имеют лайфтайм и идентификацию)

[10:14] 
которые друг другу сообщения бросают

[10:14] 
смоделируйте, как выглядит battle на хекслете в эрлангопроцессах

[10:15] 
что из себя игра представляет?

[10:15] 
игровой мир

alexelizarov [10:16 AM] 
Состояние, которое постоянно меняется, причем всеми игроками, причем возможно несколькими игроками одновременно(edited)

kirill.mokevnin [10:17 AM] 
в эрлангопроцессах)

[10:17] 
чем будет игра?
1  

alexelizarov [10:17 AM] 
Много процессов?

kirill.mokevnin [10:17 AM] 
один же

[10:17] 
игра

[10:18] 
иначе вы согласованность не сможете обеспечить

[10:18] 
если мир будет разделен на куски которые независимо меняются

[10:19] 
а пользователь подключенный к игре?

[10:20] 
я выше писал что отправка сообщения это pid ! <мессадж>

[10:20] 
соответственно с игрой идет взимодействие так pid ! <connect_player>

[10:21] 
pid ! <send_code>

[10:21] 
и так далее

[10:22] 
любой пользователь подключенный к системе, в ней представлен как процесс

[10:22] 
вот вам и ооп моделирование во всей красе

[10:22] 
можно кружочками нарисовать(edited)

[10:22] 
теперь смотрите, все же параллельно выполняется

[10:23] 
каким образом происходит синхронизация?

[10:24] 
эх, кажется что сложно для вас все это

akasstalkalex [10:25 AM] 
с игрой не очень понятно стало.

kirill.mokevnin [10:25 AM] 
почему?

[10:26] 
у игры есть состяние

[10:26] 
чат + код участников + состояние самого участника, подключен отключен

[10:26] 
все же играли в батл?

akasstalkalex [10:26 AM] 
не все)

[10:26] 
может поэтому не понятно было

kirill.mokevnin [10:27 AM] 
понял, я думал все играли

[10:27] 
в общем говоря, получается что процесс обрабатывает сообщения последовательно

[10:27] 
и всегда находится в согласованном состоянии

[10:28] 
если вам что то нужно синхронизировать при такой модели, то надо просто чтобы сообщения шли через одну точку (один процесс)(edited)

[10:28] 
которая их упорядочивает

[10:28] 
при этом процессы работают параллельно

[10:28] 
по настоящему (если больше одного ядра)

[10:28] 
так вот чем же является процесс и как его создать

[10:29] 
 ```-module(dolphins).
-compile(export_all).

dolphin1() ->
receive
  do_a_flip ->
    io:format("How about no?~n");
  fish ->
    io:format("So long and thanks for all the fish!~n");
  _ ->
    io:format("Heh, we're smarter than you humans.~n")
end.
```
(edited)

[10:30] 
 ```9> Dolphin = spawn(dolphins, dolphin1, []).
<0.53.0>
10> Dolphin ! fish.
So long and thanks for all the fish!
```
(edited)

[10:30] 
то есть dolphin1 это функция

[10:30] 
внутри используется ключевое слово receive

[10:31] 
это место где функция блокируется до получения сообщения

[10:31] 
ниже функция spawn запускает другую функцию как процесс

[10:31] 
то есть технически процесс это функция запущенная особым образом

[10:31] 
через spawn (и его вариации)(edited)

[10:32] 
а дальше вы видите как ему шлется мессадж и как он отвечает

[10:32] 
Pid ! fish

[10:32] 
после receive идет штука похожая на switch (это паттерн матчинг)

[10:32] 
этот момент понятен?

akasstalkalex [10:32 AM] 
да

alexelizarov [10:33 AM] 
понятно

[10:33] 
Dolphin - это процесс

kirill.mokevnin [10:33 AM] 
там внутри pid

[10:33] 
в эранге имена начинаются с большой буквы

[10:33] 
A = expression

[10:34] 
но это не переменная, у нас же функциональный язык)

[10:34] 
попытка сделать после этого еще раз A = another expression приведет к ошибке

[10:34] 
но выше как видно нет хранения состояния

[10:35] 
более того процесс умирает после получения сообщения

[10:35] 
потому что после вывода текста ничего не происходит

[10:35] 
функция тупо заканчивает выполнение

[10:35] 
теперь самое интересное

[10:35] 
кстати, догадаетесь как не умирать

[10:35] 
?

[10:35] 
и жить вечно)

robot_den [10:36 AM] 
хм, может рекурсия, ждать снова сообщение

kirill.mokevnin [10:36 AM] 
да!

alexelizarov [10:36 AM] 
Написать внутри recieve в каждой ветви spawn(edited)

kirill.mokevnin [10:36 AM] 
теперь сечете фишку

[10:36] 
 ```fridge1() ->
receive
  {From, {store, _Food}} ->
    From ! {self(), ok},
    fridge1();
  {From, {take, _Food}} ->
    From ! {self(), not_found},
    fridge1();
  terminate ->
    ok
end.

```

robot_den [10:37 AM] 
может я пропустил, но как хранить состояние

kirill.mokevnin [10:38 AM] 
мы к этому подообрались

[10:38] 
смотрите, мы сами себя рекурсивно вызываем

[10:38] 
и более того, шлем мессадж в ответ

[10:38] 
на From(edited)

[10:38] 
можете показать как этот процесс принимает сообщения?

[10:39] 
я имею ввиду какие вызовы

[10:39] 
Pid ! что?

[10:40] 
из кода выше видно что он принимает на вход три типа сообщений

[10:40] 
terminate - вот это последний тип

[10:40] 
понятно что он завершает процесс

[10:40] 
и выглядит так Pid ! terminate

[10:40] 
а другие два?

alexelizarov [10:41 AM] 
один принимает, другой накапливает?

robot_den [10:41 AM] 
другие два это кортежи

kirill.mokevnin [10:41 AM] 
ну вызов то покажите)

akasstalkalex [10:41 AM] 
store и take ?

kirill.mokevnin [10:41 AM] 
Pid ! ...

[10:41] 
что вместо троеточия?

alexelizarov [10:41 AM] 
store или take?

kirill.mokevnin [10:41 AM] 
любой из них

robot_den [10:42 AM] 
он проверит какой кортежи на соответствие его шаблону ?

kirill.mokevnin [10:42 AM] 
это и есть pattern matching

robot_den [10:42 AM] 
но что он ответит если ничто не совпадет ?

kirill.mokevnin [10:42 AM] 
упадет с ошибкой

[10:43] 
но вы в конце можете сделать такой паттерн _

[10:43] 
сюда придет все что не сопоставилось

alexelizarov [10:43 AM] 
как default в swith?

robot_den [10:43 AM] 
похоже на конструкцию if

kirill.mokevnin [10:43 AM] 
да

[10:43] 
паттерн матчинг это очень мощная концепция

[10:43] 
вы с помощью нее разбираете выражения и заходите во внутрь

[10:43] 
плюс она чекает соответствие

[10:44] 
{From, {store, Food}} - тут вы еще сразу получили From в котором пид того кто послал и Food который содержит полезную нагрузку

[10:44] 
возможностей тут масса

[10:44] 
вы можете сказать что {From, {_, Food}}

[10:44] 
что означает, первый элемент в кортеже не важен

[10:45] 
а еще у вас может быть сообщение {Key, Value, Key} и тут система будет убеждаться что первый и последний элемент равны между собой

alexelizarov [10:45 AM] 
А как хранить состояние все равно не вижу(

robot_den [10:45 AM] 
стой стой

kirill.mokevnin [10:45 AM] 
так вы намой вопрос еще не ответили)

[10:45] 
покажите вызов

[10:46] 
`Pid ! …`

robot_den [10:46 AM] 
Pid ! {store, Food}

alexelizarov [10:46 AM] 
так Pid ! store же либо Pid ! take. любой из них(edited)

kirill.mokevnin [10:46 AM] 
а что внутри Food?

[10:47] 
из другого процесса это будет выглядеть так `Pid ! {self(), {store, "milk"}}`

[10:47] 
покажите теперь пример с take

alexelizarov [10:48 AM] 
Pid ! { {take, "milk"}}`

[10:48] 
ответит self()

[10:48] 
а если

kirill.mokevnin [10:48 AM] 
не сматчится

[10:48] 
{From, {take, _Food}} ->

[10:48] 
структуры не изоморфны

robot_den [10:49 AM] 
store и take это функции ?

kirill.mokevnin [10:49 AM] 
структура должна быть {<something>, {take, <something>}}

[10:49] 
это атомы

robot_den [10:49 AM] 
ну конструкции языка я имел ввиду

kirill.mokevnin [10:49 AM] 
6> Atom = atom.
atom
7> Atom.
atom

[10:49] 
это атом

[10:49] 
тип данных

[10:50] 
типа строка без кавычек

[10:50] 
в кложе это кейворды, в руби символы

[10:50] 
 ```2.2.3 :001 > hash = {:key => 'asdf'}
 => {:key=>"asdf"}
2.2.3 :002 > hash[:key]
 => "asdf"
2.2.3 :003 > hash["key"]
 => nil
```
(edited)

[10:50] 
в руби они записываются :<name>

[10:51] 
считай что это константа где ее значение это ее имя

[10:52] 
к эрлангу нужно немного привыкнуть, наследие пролога сказывается

robot_den [10:53 AM] 
я предполагал что код выше что-то хранит

kirill.mokevnin [10:53 AM] 
я не про концепцию атомов (это во многих языках есть), а то что они записываются так как имена переменных в большинстве языков

robot_den [10:53 AM] 
а он просто отвечает текстом(?) при совпадении

kirill.mokevnin [10:53 AM] 
да

[10:53] 
а дальше вы так же делаете паттерн матчинг на это

[10:53] 
это не текст который печатается

[10:53] 
на основе этого дальнейшая работа и обработка строится

[10:53] 
вы же тоже процесс

[10:54] 
значит принимаете сообщения типа ok

[10:55] 
ребят, вам тоже понятно?

[10:55] 
а то мы уже вдвоем общаемся

sashashakun [10:55 AM] 
Но я же не могу обратиться паттерн матчингом внутрь структуры, устройство которой не знаю, так? Я могу только разложить приходящие данные ?

alexelizarov [10:55 AM] 
Не понял какой же вызов то для take? И как все же состояние хранится?

​

kirill.mokevnin [10:56 AM] 
вызов для тейк `Pid ! {self(), {take, "milk"}}`

robot_den [10:56 AM] 
да про состояние не понял я тоже, где мне например сохранить последний ответ

kirill.mokevnin [10:56 AM] 
{From, {take, _Food}} -> вот же строчка

[10:56] 
@sashashakun: все правильно, но это примерно говорить как, у меня в метод приходят аргументы, но я же их незнаю

[10:57] 
те сообщения которые вы можете обработать это ваш интерфейс

[10:57] 
и другие обязаны ему следовать

sashashakun [10:57 AM] 
Я понял

kirill.mokevnin [10:57 AM] 
про состояние

[10:57] 
ну парни, очевидно же

[10:57] 
)

[10:57] 
как с рекурсией состояние хранится?(edited)

alexelizarov [10:57 AM] 
накапливается

kirill.mokevnin [10:57 AM] 
ну конечно, передаете дальше в функцию

sashashakun [10:57 AM] 
В аккумуляторе

alexelizarov [10:57 AM] 
в счетчике, в аккумуляторе(edited)

kirill.mokevnin [10:58 AM] 
у вас определение функции процесса должно быть function(State)

[10:58] 
https://www.dropbox.com/s/fv69m6n3eqi7ahd/Screenshot%202016-01-12%2010.58.20.png?dl=0

kirill.mokevnin [10:58 AM] 
 shared an image: Screenshot 2016-01-12 10.58.20.png 
Add Comment
kirill.mokevnin [10:58 AM] 
спрашивайте что не понятно

[10:58] 
{Food | FoodList] - это операция добавления головы в список

[10:58] 
case это паттерн матчинг снова

[10:59] 
в фп языках не используют ифы(edited)

[10:59] 
 ```5> Pid ! {self(), {store, bacon}}.
{<0.33.0>,{store,bacon}}
6> Pid ! {self(), {take, bacon}}.
{<0.33.0>,{take,bacon}}
7> Pid ! {self(), {take, turkey}}.
{<0.33.0>,{take,turkey}}
8> flush().
Shell got {<0.51.0>,ok}
Shell got {<0.51.0>,{ok,bacon}}
Shell got {<0.51.0>,not_found}
ok
```

alexelizarov [11:00 AM] 
store -добавление элемента в список, take - удаление?

kirill.mokevnin [11:00 AM] 
ощущаете гениальность? у вас получились объекты стейт, паралленость, а в коде только рекурсия и аккумулятор

[11:00] 
да так

alexelizarov [11:01 AM] 
Ну да, получается можно получить состояние, сделать с ним что то и записать обратно. таким образом и управлять им

[11:01] 
так?

robot_den [11:01 AM] 
про сторе и тейк, это же просто атомы для матчера ? я мог бы заменить их любыми другими "фразами"

kirill.mokevnin [11:01 AM] 
конечно

[11:01] 
атомы это выбранные вами имена

[11:02] 
так вы “тегируете” ваши сообщения

[11:02] 
чтобы их различать

sashashakun [11:02 AM] 
Применение рекурсии и аккумулятора стало понятнее, вот так на первый взгляд концепция выглядит очень интересно, но это не так очевидно как самое простое "программирование классами", имхо.

kirill.mokevnin [11:02 AM] 
на основе структуры данных это делать не правильно

[11:02] 
@sashashakun: ты путаешь понятие  easy и simple

[11:02] 
классы это easy, мы всю жизнь ими пропитали

[11:02] 
но эрланг процессы это simple

[11:03] 
одна простая штука которая работает только так как ожидается

sashashakun [11:03 AM] 
Возможно, я еще не смотрел тот доклад)

kirill.mokevnin [11:03 AM] 
easy это относительное понятие

[11:03] 
что то легко потому что привычно

[11:03] 
simple это объективная величина, что штука простая, а не complex

[11:04] 
easy - hard, simple -complex

[11:04] 
классы это очень complex

[11:04] 
erlang это hard для тех кто вообще ни в зуб ногой

[11:04] 
complex - это “состоит из многих частей"

[11:05] 
так по коду понятно?

robot_den [11:05 AM] 
FoodList

kirill.mokevnin [11:05 AM] 
это просто список

robot_den [11:05 AM] 
что это за структура? это какой то тип данных?

[11:05] 
а

kirill.mokevnin [11:06 AM] 
он иницируется при запуске процесса

[11:06] 
2> Pid = spawn(kitchen, fridge2, [[baking_soda]]).

[11:06] 
первый параметр это модуль, второе это функция из модуля, третье это список аргументов

[11:06] 
в функцию

[11:06] 
в данном случае она принимает один аргумент который список

sashashakun [11:07 AM] 
Вопрос есть. Вот здесь:
Pid ! {self(), {take, "milk"}}
Будет взят элемент ''milk'' из приходящей структуры? Не зависимо от того где от в этой структуре находится?

kirill.mokevnin [11:08 AM] 
оно просто матчитца на {From, {take, Food}} ->

sashashakun [11:08 AM] 
Вообще, может опять же, это вопрос simple/easy и терминологии, но здесь несколько другой уровень абстрактного мышления

kirill.mokevnin [11:08 AM] 
From и Food здесь имена, там внутри все что угодно может быть

robot_den [11:08 AM] 
это в коде наверное определено откуда дергать пришедший аргумент

kirill.mokevnin [11:08 AM] 
а take это просто атом

alexelizarov [11:09 AM] 
Мы разве откуда то его дергаем?

kirill.mokevnin [11:09 AM] 
мы могли принимать на вход сообщения вот так {From, take, Food}

[11:09] 
просто принятно в эрланге мессадж оборачивать в кортеж

[11:09] 
и его тегируют

[11:09] 
типизация же динамическая

[11:09] 
мессадж по соглашению всегда {<randomatom>, ….}(edited)

[11:10] 
а pid того кто послал сообщение принимается в том случае если вы хотите ответить

[11:11] 
поэтому если вы не собираетесь отвечать то сообщение может быть таким `Pid ! {put, "milk"}`(edited)

sashashakun [11:11 AM] 
Тогда по другому: ! - это оператор, который позволяет нам отправить что-то куда-то, так? конструкцей pid ! {    } мы оправляем что куда? Данные процесса с pid в кортеж с правой стороны выражения, то бишь {  } ?(edited)

kirill.mokevnin [11:11 AM] 
да

[11:11] 
слева пид справа сообщение

[11:11] 
оно никак не интерпретируется и уходит целиком в процесс

sashashakun [11:11 AM] 
вот, теперь понятнее, спасибо

kirill.mokevnin [11:11 AM] 
дальше вы сами матчите

[11:11] 
как угодно

[11:12] 
ну вот представьте разницу между эрлангом и его процессами и другими языками, я вам за час щас рассказал все

[11:12] 
и вы все поняли в целом

[11:13] 
чтобы в прод фигачить эрланг достаточно пары недель входа в проект

[11:13] 
дальше как родной

sashashakun [11:13 AM] 
Я пока не привык к этим вещам, и не понимаю как в этом контексте выглядит конструкция Pid ! {put, "milk"}, то есть мы передали данные в кортеж, матчим, и причем тут строка? Мы же должны как бы матчить в "переменную", нет?

kirill.mokevnin [11:13 AM] 
а в эрланге ведь действительно ничего нет кроме функций и рекурсии, фп язык же

[11:13] 
мы и матчим в переменную

[11:13] 
как надо матчить чтобы так получилось?

[11:14] 
“milk” это полезная нагрузка

[11:14] 
матчить надо так {put, FoodName} в receive

sashashakun [11:14 AM] 
То есть мы матчим в put, и добавляем "milk"? и можно передать дальше?

kirill.mokevnin [11:14 AM] 
матчится оно целиком

[11:14] 
а не частями

[11:14] 
давай покажу

alexelizarov [11:15 AM] 
То есть ООП в erlang вообще не причем? Состоянием управляем тоже с помощтю функционального подхода? Ну да, логично, у нас же только функции и рекурсия. А почему же тогда erlang - самый лучший пример реализации ООП?

kirill.mokevnin [11:15 AM] 
```1> A = 5.
5
2> A = 3.
** exception error: no match of right hand side value 3
3> A = 5.
5
4> 5 = A
4> .
5
```

[11:15] 
= это матчинг

[11:15] 
если = происходит первый раз то это связывание

[11:15] 
у нас значение получает имя которое больше никогда не меняется

[11:15] 
дальше идет матчинг

[11:16] 
потому что эрланг это ооп по алану кею, который создал ооп

robot_den [11:16 AM] 
что за точка

kirill.mokevnin [11:16 AM] 
случайно перенес ее

[11:16] 
выражения в эрланге отделяются точками

[11:16] 
а не точкой запятой

alexelizarov [11:16 AM] 
то есть erlang можно назвать и объектно-ориентированным языком?

igrishaev [11:17 AM] 
можно, но не из-за точки ^_^(edited)

kirill.mokevnin [11:18 AM] 
```12> B = {put, "milk"}.
{put,"milk"}
13> A = B.
{put,"milk"}
14> {Name1, Name2} = B.
{put,"milk"}
15> Name1.
put
16> Name2.
"milk"
17> {take, Name2} = B.
** exception error: no match of right hand side value {put,"milk"}
```

[11:18] 
вот пример матчинг

[11:18] 
эрланг и есть объектно ориентированный язык в исконном смысле этого слова

[11:18] 
actor models была придумана и формализована на основе smalltalk

[11:18] 
который и был создан аланом кеем

[11:19] 
вы реально в эрланге мыслите объектами

[11:19] 
которые живут своей жизнью

[11:19] 
обмениваются сообщениями

[11:19] 
тут экстремально позднее связывание

sashashakun [11:19 AM] 
Вот теперь понятнее про матчинг

kirill.mokevnin [11:20 AM] 
паттерн матчинг возможен еще на функциях

[11:20] 
я много раз показывал классный хаскель пример

sashashakun [11:20 AM] 
Так почему эти концепции в свое время проиграли "программированию классами"? Там еще такая странная причина была, но не помню

robot_den [11:20 AM] 
наверное потому что hard

kirill.mokevnin [11:20 AM] 
```factorial 0 = 1
factorial n = n * factorial (n - 1)
```

[11:20] 
не, hard это всего лишь привычность, ты попробовал понял и для тебя стало easy

[11:20] 
а плюс к этому оно еще и simple(edited)

[11:21] 
и красота

sashashakun [11:21 AM] 
Ну если начинать с подобного, не думаю что так уж хард

kirill.mokevnin [11:21 AM] 
так же как математика дано не всем

[11:21] 
фп тоже дано не всем, не потому что оно сложное

[11:21] 
а потому что требует развитого абстрактного мышления

robot_den [11:22 AM] 
список это структура данных?

sashashakun [11:22 AM] 
Я еще в основном c js работаю, в коммьюнити об этом(фп) говорят, а например джавистам наверно сложно вообще потом такое видеть и понимать(edited)

robot_den [11:22 AM] 
тут

kirill.mokevnin [11:22 AM] 
это одна из самых примитивных структур данных да

[11:22] 
данные добавляются только в голову

[11:22] 
нет произвольного доступа

robot_den [11:22 AM] 
а что там еще есть например для счетчика и тру-фолс

kirill.mokevnin [11:22 AM] 
почти все что вы делаете сводится к паттерн матчингу

[11:23] 
в эрланге нет булена)

[11:23] 
true и false

[11:23] 
это просто атомы

alexelizarov [11:23 AM] 
очередь наверное можно так же сделать

kirill.mokevnin [11:23 AM] 
в сикпе вообще на парах строят все

[11:23] 
сначала списки, потом деревья

robot_den [11:23 AM] 
это если я хочу хранить последнее пришедшее ко мне сообщение то мне вычищать список и вставлять туда новое ?

kirill.mokevnin [11:24 AM] 
func([LastMessage])

[11:24] 
это просто новый список с одним значением

alexelizarov [11:24 AM] 
А получается ведь что Sheme тоже поддерживает эту идею позднего связывания?

sashashakun [11:24 AM] 
Про пары в SICP очень круто. На самом простом уровне рекурсия понимается легко, но никогда не думал, что на ней можно строить такие вещи(edited)

[11:25] 
пара->список->дерево

kirill.mokevnin [11:26 AM] 
но это еще не все, вам видно насколько просто конечные автоматы делать в этих объектах?

[11:26] 
вы просто вызываете себя не рекусивно, а определяете несколько функций с receive внутри (по количеству состояний)

[11:26] 
получаете сообщение и переходите в новое состояние

sashashakun [11:27 AM] 
Ну да, но непривычно

robot_den [11:27 AM] 
хммм,  но как мне считать например числа которые приходят ко мне и хранить результат ?

kirill.mokevnin [11:27 AM] 
но естественно

robot_den [11:27 AM] 
складывать*

alexelizarov [11:27 AM] 
в аккумуляторе

sashashakun [11:27 AM] 
Здесь в центре именно состояние, а не структура из классов, которая за всем этим стоит

kirill.mokevnin [11:27 AM] 
actor(Стейт это все что угодно)

[11:28] 
потому что создатели языка понимают в чем сложность программирования

[11:28] 
эрланг функциональный не потому что это прикольно

[11:28] 
а потому что именно так можно достичь экстра параллельности

[11:28] 
у него тупой как дрова (и очень эффектинвый) сборщик мусора

[11:29] 
умер процесс и надо просто его состояние убить

[11:29] 
оно не шарится

[11:29] 
это одна из причин почему все попытки сделать эрланг (akka в java/scala, celluloid в ruby)

[11:29] 
не смогут с ним сравниться(edited)

[11:29] 
там есть всякие stop the world

[11:29] 
а тут бай дизайн как говорится

sashashakun [11:29 AM] 
Это очень сдвигает абстрактное мышление, которое формировалось до этого

[11:30] 
Возник такой вопрос: можно ли конченым автоматом описать любую систему?

kirill.mokevnin [11:30 AM] 
любая система это конечный автомат)

sashashakun [11:30 AM] 
"любую" это условное понятие, но тем не менее

[11:30] 
понятьненько)

kirill.mokevnin [11:30 AM] 
ваша программа это конечный автомат

[11:31] 
тыкнули сюда, стала такой

[11:31] 
тыкнули сюда стала такой

[11:31] 
у вас есть события (кнопки, cli интерфейс)

[11:31] 
внутри меняется состояние

[11:31] 
но это еще не все

[11:31] 
эрланг это soft real-time система

[11:32] 
представьте веб сервер на эрланге

[11:32] 
как вы думаете, вот подключается человек

[11:32] 
что для него создается?)

robot_den [11:32 AM] 
процесс?

kirill.mokevnin [11:32 AM] 
да

[11:32] 
а что будет если упадет процесс?

robot_den [11:32 AM] 
данные будут потеряны

alexelizarov [11:32 AM] 
создастся новый

kirill.mokevnin [11:32 AM] 
а для программы в целом?

alexelizarov [11:32 AM] 
?

john_mephistophilus [11:32 AM] 
для программы  - ничего(edited)

kirill.mokevnin [11:32 AM] 
именно

[11:33] 
идеология эрланга let it crash

[11:33] 
джо армстронг при создании эрланга исходил из “ошибки это нормально"

[11:33] 
давайте не будем их обрабатывать, пусть процессы падают

[11:33] 
теперь сравните это с любым другим языком

[11:33] 
вот у вас на ноде эвент луп

[11:34] 
обрабатываются сообщения в одном процессе от фронтенда по вебсокетам, чат какой нибудь

[11:34] 
и один чувак делает что то такое что его комната падает

[11:34] 
упадет весь процесс

sashashakun [11:34 AM] 
Упадет сразу все

dstarcev [11:34 AM] 
Сохраните, пожалуйста, этот разговор

kirill.mokevnin [11:34 AM] 
вам нужно по всей программе везде ставить защиту

[11:34] 
в эрланге по дефолту ничего нигде не упадет дополнительно

[11:34] 
упадет только ваш процесс

sashashakun [11:34 AM] 
Ну ладно, думаю я сформировал главный вопрос чата: почему все еще не пишут на эрланге?

robot_den [11:35 AM] 
:smiley:

kirill.mokevnin [11:35 AM] 
он узкоспециализированный язык

john_mephistophilus [11:35 AM] 
сложноть перестроиться с классов)

kirill.mokevnin [11:35 AM] 
не

[11:35] 
почти всегда эрланг это второй и не основной язык

igrishaev [11:35 AM] 
@sashashakun: а вы что вакансии не гуглили?

sashashakun [11:35 AM] 
Если с нуля учить то не будет сложности

kirill.mokevnin [11:35 AM] 
на нем пишут системы массового обслуживания с требованиями по отказоустойчивости и масштабируемости

[11:35] 
там где это критично

sashashakun [11:35 AM] 
@igrishaev: по эрлангу? нет, а что там, все плохо?

kirill.mokevnin [11:36 AM] 
поэтому обычно в больших проектах всегда где то есть эрланг

[11:36] 
но о нем даже в вакансиях часто не пишут

[11:36] 
вот у коуба есть эрланг, вы не найдете вакансию по этому поводу

[11:36] 
и так далее

igrishaev [11:36 AM] 
@sashashakun: а вы погуглите. там все хорошо, в.т.ч. и в России

kirill.mokevnin [11:37 AM] 
россия по эрлангу одна из топовых стран

sashashakun [11:37 AM] 
хорошо, посмотрю)

kirill.mokevnin [11:37 AM] 
большинство крутых девелоперов мировых русскоязычные(edited)

[11:37] 
и либы написаны русскоязычными

[11:37] 
http://novosibirsk.hh.ru/vacancy/12566338 (8KB)


[11:38] 
вы обратите внимание что пишут в вакансиях где слово erlang встречается

[11:38] 
там уровень требуется чуть ли не PhD

[11:39] 
не потому что эрланг сложный, а обычно там где он есть, решают по настоящему сложные задачи

[11:40] 
я уж не говорю про hot code reload, подобное только в кложе еще есть

[11:40] 
ну и про soft real-time тоже не рассказал)

[11:40] 
ну и вы поняли, вот у вас нода запустилась и живет на ядре, эрланг запустился и занял все доступные ядра

[11:41] 
перенесли программу на более мощный сервак (по количеству ядер), производительность поперла вверх

[11:41] 
в общем ушли уже от ооп), но надеюсь ваше сознание теперь расширилось

[11:41] 
изучайте эрланг во имя добра

[11:41] 
он вас сделает более лучшими инженерами
1  

alexelizarov [11:42 AM] 
А есть вообще хоть какие-нибудь преимущества у класс-ориентированного подхода?

kirill.mokevnin [11:42 AM] 
утилитарные точно есть

[11:42] 
куча кода, куча разработчиков, мейнстрим, спецификации

sashashakun [11:43 AM] 
Вакансия крутая но ничего космического не увидел, кроме того что редко пишут так явно "Имеете высшее образование в области разработки программного обеспечения и информационных технологий."

kirill.mokevnin [11:43 AM] 
ну окей, я просто знаю этих ребят)

[11:43] 
это лев валкин

sashashakun [11:43 AM] 
Но видимо это как раз то место где будут спрашивать по хардкору)(edited)

kirill.mokevnin [11:43 AM] 
да

[11:44] 
это те парни которые на тестовом задании просят лидер элекшен реализовать

[11:44] 
большинство разработчиков даже понятия не имеют о чем это

[11:44] 
https://en.wikipedia.org/wiki/Leader_election

sashashakun [11:44 AM] 
Я в этом чатике об этом узнал:D

densom [11:44 AM] 
Почему большинство не знают об этом ?

alexelizarov [11:44 AM] 
А как так получилось что у класс-ориентированного подхода куча кода, куча разработчиков? Почему этого не оказалось у функционального подхода?

kirill.mokevnin [11:45 AM] 
потому что распределенные системы это не то чем занимается большинство

[11:45] 
ну дык я ж написал выше, мир императивный люди мыслят императивно

[11:45] 
чтобы мыслить декларативно нужно завести внутри себя маленького математика

rakhim [11:45 AM] 
Вот кстати на правильных computer science-программах в универах это обязательно проходят, и пишут реализации

kirill.mokevnin [11:46 AM] 
вы обратите внимание с каким скрипом люди проходят сикп и особенно наш курс “основы программирования"

[11:46] 
как только доходят до “передать функцию как аргумент” 80% людей просто не понимает что вообще творится

[11:46] 
при этом мы опрос делали, те же люди легко делают jquery.onchange(function()...

sashashakun [11:47 AM] 
Ну это как раз просто имхо, вот штуки типа деревьев на парах и рекурсии уже сложно представить в голове

akasstalkalex [11:47 AM] 
не сложнее, с этим сталкиваешься просто намного реже

alexelizarov [11:47 AM] 
Так это потому что в универах так обучают. Я вот на 3 курсе сейчас, в универе никто ни разу и слова не сказал про ФП

sashashakun [11:47 AM] 
Или я один представляю это в голове?)

kirill.mokevnin [11:47 AM] 
ну представь что твоя программа выполняется на механических реле

alexelizarov [11:47 AM] 
Если бы мне в первой день универа СИКП показали я думаю что легче его понял бы

kirill.mokevnin [11:47 AM] 
не сможешь

[11:47] 
это тоже самое

[11:48] 
просто всегда растет уровень абстракции

[11:48] 
когда ты конструируешь абстракцию “списки” то там важно про пары знать

[11:48] 
дальше все, барьер абстракции

[11:48] 
никаких пар

[11:48] 
и так далее

[11:48] 
и если эти уровни правильно делить (а это и есть программирование так то), то все будет легко на каждом текущем уровне

[11:48] 
но всю цепочку в голове не уложишь

v.manenkov [11:49 AM] 
Это как раз очень просто :simple_smile:

[11:49] 
Если уже сам пытался что-то более менее серьезное написать

[11:50] 
То все эти барьеры абстракции видятся решением проблем

sashashakun [11:50 AM] 
Да, это я понимаю)

[11:51] 
Книжка по эрлангу на русском, если кому надо: 
https://github.com/mpyrozhok/learnyousomeerlang_ru

GitHub
mpyrozhok/learnyousomeerlang_ru
learnyousomeerlang_ru - Перевод "Learn You Some Erlang For Great Good" на русский

kirill.mokevnin [11:52 AM] 
знаете как понять куда эрланг совать

[11:52] 
если у вас есть веб сервис с shared  state например

[11:52] 
игры, чаты

igrishaev [11:52 AM] 
@alexelizarov: на ФП языках тоже пишут, просто меньше. Но пропорции не должны вас беспокоить.(edited)

kirill.mokevnin [11:52 AM] 
это идеальное место

[11:53] 
да кстати, вот я вращаюсь в мире где большинство разработчиков используют фп каждый день в свое жизни, а очень многие только на таких языках пишут

sashashakun [11:53 AM] 
Как определить, что state собственно shared?

kirill.mokevnin [11:54 AM] 
ну дык просто ж, если у тебя есть взаимодействие пользователей

[11:54] 
иногда это можно и через базу сделать, но это в случае очень слабого взаимодействия (по интенсивности)

[11:54] 
в играх и чатах такое не катит

[11:54] 
вот мы тут общаемся

[11:54] 
эрланг самое то

[11:54] 
вы знаете кстати проект kato?

sashashakun [11:55 AM] 
нет

kirill.mokevnin [11:55 AM] 
это слак тоже, наши сделали, на эрланг

[11:55] 
щас покажу

[11:55] 
они переименовались правда

[11:55] 
https://sameroom.io/open-a-tube
Sameroom
Sameroom unifies chatrooms
Sameroom helps connect chatrooms (even when they’re running on completely different services). (30KB)


[11:55] 
хм, парни концепцию сменили

densom [11:56 AM] 
А java включает возможности erlang? что там в интерпрайзе...

kirill.mokevnin [11:56 AM] 
читай про akka

[11:56] 
это actor models для jvm экосистемы

[11:56] 
http://habrahabr.ru/company/kato/blog/245471/ вот тут немного они писали как эрланг им помогает

Как веб-сервер Cowboy и мессенджер Kato помогают друг другу: Немного про Erlang и open source
Большая часть сервисов и продуктов, которыми все мы пользуемся каждый день, были построены с применением открытых технологий (open source). Например,...

sashashakun [11:57 AM] 
Так то соединение мессенджеров тем более самое место для эрланга, если он используется в собственно мессенджерах

kirill.mokevnin [11:57 AM] 
кстати смотрите еще в чем профит

[11:57] 
вот когда говорят про быстрый веб

[11:57] 
и типа вот нода

[11:57] 
очень часто там ноду можно заменить на эрланг и лучше это сделать

[11:57] 
кроме всех плюшек эрланга есть еще одна очень важная

[11:58] 
в ноде у вас код асинхронный

[11:58] 
со всеми вытекающими

[11:58] 
в эрланге вы можете породить сотни тысяч акторов

[11:58] 
и в каждом заблокриоваться

sashashakun [11:58 AM] 
Нода проще, нет? Колбек туда, колбек сюда.

kirill.mokevnin [11:58 AM] 
нет, 1000 строк кода, две вложенности и потерялся

[11:58] 
навсегда

[11:58] 
в эрланге десятки сотни тысяч строк кода и все ок

[11:58] 
код одинаковый и тупой

[11:58] 
очень командный язык

[11:59] 
писать по разному невозможно почти

[11:59] 
так вот вы по сути получаете обычное блокирующее программирование (на уровне вызова методов, io операций), но со скоростью сопоставимой с сырым event loop

[11:59] 
а если учесть еще что эрланг по всем ядрам расходится

[11:59] 
то так вообще

[12:00] 
вы можете даже в ваших процессах числодробилки делать

[12:00] 
остальной код будет тоже работать

[12:00] 
попробуйте в ноде хоть в одном процесс json распарсить

[12:00] 
ой, хоть в одном обработчике

[12:01] 
все это возможно как раз за счет soft realtime

[12:01] 
у эрланга очень умный шедулер, с вытесняющей многозадачностью

[12:01] 
вообще эрланг, как уже видно, это операционная система

[12:01] 
даже есть проект erlang on xen, где он запускается на голом железе

[12:01] 
http://erlangonxen.org/

sashashakun [12:02 PM] 
Чтобы эффективно пользоваться таким инструментом, надо знать внутреннее устройство ОС

kirill.mokevnin [12:02 PM] 
ну здрасте, программировать эффективно без знания операционных систем это вообще нонсенс

[12:02] 
тем более в эвент лупах

[12:03] 
особенно в обычных языках а не на ноде

sashashakun [12:03 PM] 
Не ну можно гостевухи писать)

kirill.mokevnin [12:03 PM] 
как блокироваться не блокироваться

[12:03] 
что нельзя вызывать блокирующие операции

sashashakun [12:03 PM] 
>erlang on xen
В чем профит? Небывалая скорость?

kirill.mokevnin [12:03 PM] 
небывалая

[12:03] 
поднять виртуалку за 50 милисекунд

[12:03] 
можно это делать на запрос

alexelizarov [12:04 PM] 
А можно вот еще прояснить? На конкретном примере. Вот, например, у нас никакая не многопользовательская система, даже не веб-приложение, отказоустойчивость не важна. Калькулятор надо обычный написать десктопный) У меня в универе такая лабораторная была) Имеет смысл такую программу писать на erlang?

kirill.mokevnin [12:04 PM] 
нет

[12:04] 
можно но нет

[12:04] 
эрланг же тьюринг полный язык, значит на нем все можно написать(edited)

[12:04] 
тут вот в чем проблема, у него все очень плохо с обычными либами

[12:05] 
на эрланге нет orm

[12:05] 
нет кучи обычных либ

alexelizarov [12:06 PM] 
По-другому спрошу: а в принципе ФП? Может оно пригодится в такой задаче?

sashashakun [12:06 PM] 
Что может понадобиться в калькуляторе из "обычных либ"? GUI да, а что еще?(edited)

alexelizarov [12:06 PM] 
мне кажется да

[12:06] 
я писал чисто в императивном стиле

[12:06] 
на java

[12:06] 
и имел кучу проблем

kirill.mokevnin [12:07 PM] 
лямбда исчисление равномощно машине тьюринга

sashashakun [12:07 PM] 
я вот не понял что значит эта фраза:sweat_smile:

densom [12:08 PM] 
можно написать любой алгоритм

[12:08] 
одинаковые по возможностям

[12:08] 
устройства

v.manenkov [12:08 PM] 
alexelizarov: это ещё не значит, что эрланг поможет

alexelizarov [12:08 PM] 
Что можно любую задачу решить и в ФП стиле и в императивном стиле?

v.manenkov [12:08 PM] 
Да

kirill.mokevnin [12:09 PM] 
возможности языков определяются тьюринг полнотой

[12:09] 
кстати, ничего что я один тут без образования айтишного и вам это рассказываю? :smile:

[12:09] 
это университетская база

sashashakun [12:09 PM] 
у меня тоже нет образования айтишного)

akasstalkalex [12:10 PM] 
университеты разные бывают))

kirill.mokevnin [12:10 PM] 
точнее у меня вообще нет высшего

[12:10] 
ну окей

[12:10] 
В теории вычислимости исполнитель (множество вычисляющих элементов) называется тьюринг-полным, если на нём можно реализовать любую вычислимую функцию. Другими словами, для каждой вычислимой функции существует вычисляющий её элемент (например, машина Тьюринга) или программа для исполнителя, а все функции, вычисляемые множеством вычислителей, являются вычислимыми функциями (возможно, при некотором кодировании входных и выходных данных).

Название пошло от Алана Тьюринга, который придумал абстрактный вычислитель — машину Тьюринга и дал определение множества функций, вычислимых посредством машин Тьюринга.

[12:11] 
"Вместе с ней λ-исчисление обладает свойством полноты по Тьюрингу и, следовательно, представляет собой простейший язык программирования."

[12:11] 
хотите прикол по этому повооду

[12:11] 
есть такое понятие в математике

[12:11] 
базис

[12:11] 
некий минимальный набор элементов который позволяет решить поставленную задачу

[12:11] 
вот представьте такой язык который включает в себя вообще все

[12:11] 
может включать все

[12:12] 
что в него надо включить (базисы могут быть разные) так чтобы остался самый минимальный базис

[12:12] 
базис относительно тьюринг полноты

[12:12] 
то есть что надо оставить чтобы язык остался тьюринг полным

alexelizarov [12:12 PM] 
математические операции, вызовы ф-ий, условия

kirill.mokevnin [12:13 PM] 
хаха условия не нужны

sashashakun [12:13 PM] 
рекурсия

kirill.mokevnin [12:13 PM] 
да собственно лямбда исчисление и нужно, это минимально возможная штука

[12:13] 
у вас только функции

[12:13] 
и даже рекурсия не нужна

[12:13] 
она реализуется посредством неподвижной точки

[12:13] 
например y-combinator

[12:14] 
а в свою очередь это означает что все другие элементы можно построить из этих элементов

[12:14] 
то есть получается с этой точки зрения циклы это сахар

[12:14] 
:wink:

[12:15] 
это не так, потому что сахар это когда лучше, а не когда “другое"

[12:15] 
но вот такой забавный факт

alexelizarov [12:15 PM] 
Но если язык не поддерживает хвостовую рекурсию без циклов же никуда?

kirill.mokevnin [12:15 PM] 
хвостовая рекусия она есть

[12:16] 
сама по себе

[12:16] 
а вот ее оптимизация в кишках это другой вопрос

[12:16] 
важно что это деталь реализации внутри

[12:16] 
а не в интерфейсе языка

[12:16] 
но даже если ее нет, мы же теоретические выкладки сейчас делаем

[12:17] 
отсутствие оптимизации просто потребует другого распределения памяти, под стек побольше)

[12:17] 
язык от этого не перестанет быть тьюринг полным

[12:18] 
у кого сегодня рабочий день потерян?)
3  

dstarcev [12:18 PM] 
Ни php ни руби ни питон ни java не оптимизируют вроде

[12:18] 
ES6 вроде да

kirill.mokevnin [12:18 PM] 
кстати по этой причине в clojure есть хак

[12:18] 
когда используется рекусивная функция то надо делать вот так (recur func)

[12:19] 
это сделано не потому что “нереализовали"

v.manenkov [12:19 PM] 
> отсутствие оптимизации просто потребует другого распределения памяти, под стек побольше)
чем больше уходим вниз по рекурссии, тем больше. В общем случае я бы вообще тогда на стек не стал рассчитывать. 
А вообще говорилось изначально, что циклы - это сахар. Это правда. То что нет оптимизации - вопрос вторичный.

kirill.mokevnin [12:19 PM] 
там невозможно по другому из за политики безопасности внутри jvm

[12:19] 
в ruby есть tail recursion optimisaion внезапно(edited)

[12:20] 
RubyVM::InstructionSequence.compile_option = {
 tailcall_optimization: true,
 trace_instruction: false
}

v.manenkov [12:20 PM] 
Никто же не предлагает идеи из ФП на джаве реализоывывать. Вы так джава машину уроните.

alexelizarov [12:20 PM] 
А правильно я понимаю, что если у нас нет управления состоянием (а в калькуляторе именно так), то лучше использовать ФП? И почему? Машина Тьюринга же эквивалентна лямбда-исчислению?

vgv [12:20 PM] 
> там невозможно по другому из за политики безопасности внутри jvm
эмм, где бы подробнее почитать?

[12:21] 
clojure же вообще интерпретатор, не?

kirill.mokevnin [12:21 PM] 
о, я думал ты мне скажешь)

[12:21] 
смотри что я слышал

[12:21] 
это связано с контекстом функции

alexelizarov [12:21 PM] 
@v.manenkov: А почему нельзя на java? Там же лямбда добавили?

kirill.mokevnin [12:21 PM] 
чтобы была полная независимость

[12:21] 
хвостовая рекурсия внутри все это сводит в одно пространство с циклом (грубо говоря)

v.manenkov [12:21 PM] 
alexelizarov: Я про циклы vs рекурсия, а насчет лямбд не знаю. Там ведь даже и замыкания вроде есть.(edited)

kirill.mokevnin [12:21 PM] 
щас гляну в доке

vgv [12:22 PM] 
Я к тому что clojure вообще может эту функцию в цикл развернуть и всё

kirill.mokevnin [12:22 PM] 
он это и делает, если ты ей скажешь recur

[12:22] 
кложа она ведь?)

igrishaev [12:22 PM] 
насчет кложи не путайте коров с лошадьми
это язык. есть реализация на Джаве и дот.Нет
в обоих случаях код кложи компилится в байт-код целевой машины

kirill.mokevnin [12:23 PM] 
https://clojurebridge.github.io/community-docs/docs/clojure/recur/

ihorbryk [12:23 PM] 
joined #computer_science

kirill.mokevnin [12:23 PM] 
Even though we can write code without recur, the use of recur is strongly recommended in Clojure because of tail-call optimization (TCO).

vgv [12:23 PM] 
> в обоих случаях код кложи компилится в байт-код целевой машины
clojure это интерпретатор или нет?

kirill.mokevnin [12:23 PM] 
то есть без нее не может

igrishaev [12:23 PM] 
Кложа это язык. Документ, соглашение, дизайн

vgv [12:23 PM] 
Я к тому что clojure может посмотреть на функцию, вывести что все вызовы могут быть оптимизированы и преобразовать в цикл

[12:23] 
Сама, без подсказок

[12:24] 
> Кложа это язык. Документ, соглашение, дизайн
Cпасибо. А на мой вопрос ответите?

kirill.mokevnin [12:24 PM] 
http://stackoverflow.com/questions/19462314/why-cant-tail-calls-be-optimized-in-jvm-based-lisps

Why can't tail calls be optimized in JVM-based Lisps?
Main question: I view the most significant application of tail call optimization (TCO) as a translation of a recursive call into a loop (in cases in which the recursive call has a certain form). M...

vgv [12:24 PM] 
Да вот я и читаю как раз этот ответ

kirill.mokevnin [12:24 PM] 
а вот http://stackoverflow.com/questions/3616483/why-does-the-jvm-still-not-support-tail-call-optimization

Why does the JVM still not support tail-call optimization?
Two years after does-the-jvm-prevent-tail-call-optimizations, there seems to be a prototype implementation and MLVM has listed the feature as "proto 80%" for some time now. Is there no active inte...

[12:25] 
@alexelizarov абсолютно верно, если у вас функция чистая то там нет состояния по определению

vgv [12:25 PM] 
Я просто давно не смотрел, clojure код моей программы сначала в байт-код переведет или нет?

kirill.mokevnin [12:25 PM] 
и вводить его искуственно это усложнять софт

[12:25] 
там есть варианты

[12:26] 
http://clojure.org/compilation

[12:27] 
кстати, все представляют себе как реализовать ифы без ифов?

[12:27] 
посмотрите числа черча, чтобы себе мозг окончательно вынести

[12:27] 
если кто еще не видел

john_mephistophilus [12:28 PM] 
функцией

kirill.mokevnin [12:30 PM] 
http://habrahabr.ru/post/248331/ собственно вот

Вычисление факториала на числах Чёрча
Доброго дня, друзья! Тема функционального программирования раскрыта на Хабре весьма неплохо, есть целая куча статей посвященных λ-исчислению, числам Чёрча и...

igrishaev [12:30 PM] 
@vgv конкретно clojure.jar это компилятор лиспового кода в байткод JVM

netxor [12:32 PM] 
ребя, а где начала сообщения по эрлангу? хочу в архив добавить

kirill.mokevnin [12:33 PM] 
@vgv раз ты тут, я вот пишу про ооп что то, и знаю что ты со мной во многом не согласен (да ведь?), а вопрос ведь висит, в чем фишка ооп в современной интерпретации, что правильно/неправильно в ява с твоей позиции, в чем плюсы в чем смысл? правильно ли наличие классов? трейты? а может классы типов? почему протоколы лучше интерфейсов :wink: ?(edited)

sashashakun [12:33 PM] 
@netxor: https://hexlet-ru.slack.com/archives/computer_science/p1452578109002452
alexelizarov
Помогите пожалуйста разобраться. В Википедии написано про лямбда-исчисление:   ​*λ-исчисление может рассматриваться как семейство прототипных языков программирования*​. И после этого написано еще:   ​*Тем самым обеспечивается систематический подход к исследованию операторов, аргументами которых могут быть другие операторы, а значением также может быть оператор. Языки в этом семействе являются функциональными.*​ То есть из этого я делаю вывод, что языки в семействе прототипных являются функциональными. Show more...
Yesterday at 8:55 AM

netxor [12:34 PM] 
@sashashakun: спасибо!

andreydruzhinin [12:37 PM] 
joined #computer_science

dstarcev [12:42 PM] 
Тут у нас спор возник. Есть большой интерфейс в java, java.lang.List.

[12:42] 
Его реализуют всякие разные списки, в том числе и LinkedList

[12:42] 
и есть у него метод get(int index)

[12:43] 
и вопрос: нужен ли такой метод в связном списке вообще?

[12:43] 
я считаю что ему нужен отдельный интерфейс

vgv [12:43 PM] 
2kirill.mokevnin - да, интересный вопрос, но прямо сейчас я не могу, у нас немного всё упало )

kirill.mokevnin [12:46 PM] 
@dstarcev: могу тебе внезапно альтернативный взгляд предложить

[12:46] 
про интерфейсы

dstarcev [1:18 PM] 
@kirill.mokevnin какой?

kirill.mokevnin [1:22 PM] 
хотя забей), единственное что могу сказать, не существует какого-то одного правильного способа построения абстракций

[1:23] 
в одних ситуациях одно лучше ложиться, в других другое

dstarcev [1:23 PM] 
ну в общем должна ли сложность алгоритмов быть частью контракта?

kirill.mokevnin [1:24 PM] 
нет никакого должна, есть “удобно ли такая компоновка на практике"

dstarcev [1:25 PM] 
ок, я кейс приведу

[1:26] 
например я пишу класс, у которого в зависимостях список

kirill.mokevnin [1:26 PM] 
ну так я выше написал, что всегда можно найти кейс когда текущее разбиение неудобное

[1:26] 
нет универсального способа

dstarcev [1:27 PM] 
и я хочу обращаться по индексу. по идее этот метод есть в List и можно сделать зависимость от интерфейса. но если мне подсунут большой связный список, все будет тупить

kirill.mokevnin [1:30 PM] 
ну так этож не проблема абстракции

[1:30] 
смотри, есть такая штука как класс типов, сильно более гибкая чем интерфейс

vgv [1:31 PM] 
Нет, вы неправильно смотрите на это

[1:31] 
я автору топика

kirill.mokevnin [1:31 PM] 
например можно определить класс типов Show и задекларировать там метод show

vgv [1:31 PM] 
У структуры данных “список” есть такое понятие как “индекс элемента” ?

[1:31] 
Очевидно есть, список - упорядочен(edited)

[1:32] 
Это не множество

kirill.mokevnin [1:32 PM] 
а потом в любом месте программы вы можете расширить любой тип

vgv [1:32 PM] 
А значит метод, который достает элемент по индексу - это метод очень подходящий для списка

[1:32] 
А вот его временная и прочие сложности не играют роли

[1:32] 
Для описания возможностей, которые есть у списка

kirill.mokevnin [1:33 PM] 
здесь пропадает то ограничение которое есть у интерфейсов (искуственное), это задание интерфейсов только на уровне определений, так вот это в свою очередь означает что вы в любой момент кому угодно можете что угодно присобачить

[1:33] 
это я к тому чтобы была видна грань между понятием абстракция и построением абстракции

[1:34] 
не уровень это кода решать какая абстракция эффективна а какая нет, не может он этого

dstarcev [1:34 PM] 
Кирилл, речь о трейтах?

kirill.mokevnin [1:34 PM] 
нет

[1:34] 
трейты содержат реализацию

[1:34] 
они немного для другого

[1:34] 
класс типов это грубо интерфейс который динамически цепляется

[1:35] 
они позволяют обвешивать функциональностью в том числе стандартные типы

dstarcev [1:35 PM] 
@vgv  значит у бесконечной последовательности тоже может быть индекс, она ведь упорядочена

vgv [1:35 PM] 
Да

kirill.mokevnin [1:35 PM] 
более того в хаскеле так и работает

[1:35] 
определяешь бесконечную последовательность

[1:35] 
и просишь десятый элемент

vgv [1:35 PM] 
И если вы у ленивой последовательности запросите Nth элемент - будет eager fetch(edited)

kirill.mokevnin [1:36 PM] 
что оно и есть

dstarcev [1:36 PM] 
Мне кажется тут можно выстрелить в ногу с большой вероятностью, если ты точно не знаешь с какой структурой данных работаешь

kirill.mokevnin [1:37 PM] 
так это от тебя как от проектировщика зависит

dstarcev [1:37 PM] 
ага, либо проектировщика либы

vgv [1:39 PM] 
Вы либо в документации к своему методу указывайте что внутри метода агрессивный поиск по индексу

[1:39] 
Либо прямо в сигнатуре требуйте явную реализацию списка

[1:40] 
Потому что если так рассуждать - то и метод size() не нужен связному списку, он же тоже будет перебором работать в ряде реализаций

kirill.mokevnin [1:41 PM] 
при этом намного круче что ваша функция может работать с большим количеством данных чем наоборот

[1:41] 
мне это напоминает такую штуку как final

dstarcev [1:42 PM] 
> Либо прямо в сигнатуре требуйте явную реализацию списка
я бы не хотел явную реализацию, я бы хотел любую реализацию с константным доступом по индексу :simple_smile:

vgv [1:42 PM] 
Тогда в документации пишите про это(edited)

kirill.mokevnin [1:43 PM] 
зачем?

dstarcev [1:43 PM] 
это к кому вопрос?)

kirill.mokevnin [1:43 PM] 
к тебе

[1:43] 
это филосовский вопрос больше

[1:44] 
интерфейсы это про типы и их согласованность

[1:44] 
скомпилилось работает

[1:44] 
ты исходишь из того что программист не способен догадаться? или из чего?

dstarcev [1:46 PM] 
я исхожу из того, что лучше иметь как можно меньше способов накосячить

kirill.mokevnin [1:46 PM] 
а косяки то тут причем?

dstarcev [1:47 PM] 
ну ошибки это плохо(edited)

kirill.mokevnin [1:47 PM] 
так кто тебе сказал что это ошибка?

[1:47] 
у человека структура список и ему так надо и удобно

[1:47] 
он радостный берет твою либу

[1:47] 
а она такая, нука переписывай нафиг все

dstarcev [1:48 PM] 
ну мы же когда хотим массив, говорим: этот метод принимает массив

[1:48] 
это нормально?(edited)

kirill.mokevnin [1:48 PM] 
не потому что у него константный доступ

dstarcev [1:48 PM] 
если я хочу массив, значит мне нужны его свойства

kirill.mokevnin [1:49 PM] 
а потому что мы работаем с таким интерфейсом

[1:49] 
смотри, с точки зрения программ, та программа лучше которая может обрабатывать больше разного за те же деньги фигурально выражаясь(edited)

[1:49] 
что то из этого будет эффективнее обрабатываться что то нет

[1:50] 
ну я тебе еще могу пример с другой стороны написать

dstarcev [1:50 PM] 
ну да, но придется заплатить за это памятью или процом внутри

[1:50] 
и возможно тот кто юзает либу хотел бы знать об этом

kirill.mokevnin [1:50 PM] 
ну давай с другой стороны, вот у тебя на вход логгер принимается и ты там все логгируешь

[1:50] 
часто

[1:51] 
приходит новый разработчик пишет логгер который делает oauth на какой нибудь сервис loggly и начинает не локально работать а в сеть ходить

[1:51] 
ну и как понимаешь аналогичных примеров два миллиона можно привести

[1:51] 
даже с твоим “отдельный интерфейс на get"

[1:51] 
ну взял я свой кастомный список и реализовал этот интерфейс

dstarcev [1:51 PM] 
ну с логгером это очевидно, это очень популярный интерфейс

kirill.mokevnin [1:52 PM] 
или вообще сделал реализацию что в базе хранить начал структуру

[1:52] 
get запрос в базу делает

vgv [1:52 PM] 
или в /dev/null

kirill.mokevnin [1:52 PM] 
норм же идея?)

vgv [1:52 PM] 
отличная!!!  ))(edited)

dstarcev [1:53 PM] 
значит вопрос сводится к тому

kirill.mokevnin [1:53 PM] 
еще смотри пример, в фп языках есть операция добавления в конец

[1:53] 
в структуры

dstarcev [1:53 PM] 
как сделать чтобы разработчик осознанно дергал методы в моей либе

kirill.mokevnin [1:53 PM] 
и она почти для всех структур супер не эффективная

[1:53] 
но иногда так надо делать

dstarcev [1:53 PM] 
и не посылать его в доки при этом

kirill.mokevnin [1:54 PM] 
но в кложе например есть фукнция conj, которая добавляет элемент туда куда эффективнее всего в зависимости от типа структуры

[1:54] 
у нее такова семантика

[1:54] 
если у тебя код рассчитывает на порядок, то получишь фигу

[1:54] 
но семантику функции ты обязан знать когда с ней работаешь

[1:55] 
вопрос даже сводится к следующему

[1:55] 
нормально ли что разработчик который работает с большим объемом данных и хочет произвести конкретную операцию с ними, не понимает как теоретически это работает

[1:56] 
и что для эффективного выполнения этой операции нужен индексированный доступ быстрый

[1:56] 
в целом нормально наверное), поэтому нужна дока

[1:57] 
еще из примеров, как бы ты такое решал, часто девелоперы (и не новички даже) делают выборки из базы прямо в код

[1:57] 
и там сортируют, лимитируют (слайс какой нибудь), даже фильтрацию проводят

[1:59] 
отдаленно то что ты говоришь напоминает зависимые типы

[1:59] 
https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D1%8B%D0%B9_%D1%82%D0%B8%D0%BF

[1:59] 
но там другая проблематика решается

dstarcev [2:00 PM] 
чаще всего лучше на стороне базы сделать все нужные фильтры и агрегацию

kirill.mokevnin [2:00 PM] 
так понятно, я как раз о том как разработчик либы для доступа к базе может ограничить от такой штуки?

[2:00] 
они же тоже хотят чтобы эффективно все делалось

dstarcev [2:01 PM] 
легко

[2:01] 
он должен сделать метод count

[2:01] 
и сделать его эффективно

kirill.mokevnin [2:01 PM] 
да никак ты не сделаешь, человек сделал выборку а дальше уже он в языке вне твоей либы

dstarcev [2:01 PM] 
а если метода нет, то юзер запросит список и возьмет его длину

[2:01] 
обязательно

kirill.mokevnin [2:01 PM] 
это реально частый кейс у новичков, выборку делает целиком и коде уже слайс

lisovskyvlad [2:01 PM] 
результат можно завернуть в определённый тип

kirill.mokevnin [2:01 PM] 
с 1 по 10

vgv [2:01 PM] 
у тебя в либе есть метод executeSql(statement)

[2:02] 
как ты ограничишь?

lisovskyvlad [2:02 PM] 
намекну на activerecord

kirill.mokevnin [2:02 PM] 
похоже я плохо объяснил

[2:02] 
разработчик делает data = execute(sql)

lisovskyvlad [2:02 PM] 
ой фу

kirill.mokevnin [2:02 PM] 
а потом во вью передает data[1, 10]

[2:03] 
как вы можете заставить его лимит в базе делать а не в коде?

dstarcev [2:03 PM] 
ну если у него только один этот метод, то никак не ограничишь

kirill.mokevnin [2:03 PM] 
да даже если 10, он всегда может пойти тем путем который не желателен

[2:03] 
я это не с потолка взял, а часто натыкался на подобные вещи

[2:03] 
люди просто не понимают что вообще происходит

[2:03] 
работает и работает

[2:04] 
а потом оказывается что они в память сотни тысяч строк грузят

dstarcev [2:04 PM] 
да, но хотя бы можно подтолкнуть его к правильному исопльзованию либы, если есть специфические методы кроме execute

[2:04] 
но от умного дурака защиты никогда нет

lisovskyvlad [2:04 PM] 
а что если использовать ленивые структуры данных?)

kirill.mokevnin [2:05 PM] 
да ничего не получится), я на своем опыте вот к чему пришел, программные средства защити типа final того же, ничего не поможет, они только усложняют код из-за наличия новых сущностей

lisovskyvlad [2:05 PM] 
пусть либа возвращает некий promise?

[2:05] 
лан, убедили,

kirill.mokevnin [2:05 PM] 
так же как говорят про инкапсуляцию в ооп (не вдаемся в детали, все там сложнее) что мол она защищает от нерадивых программистов

[2:06] 
это вообще бред, парадигма программирования построенная на человеческом факторе

vvalgis [2:06 PM] 
Инкапсуляция не для защиты, а для информирования об интерфейсе

kirill.mokevnin [2:06 PM] 
1) она не защищает (по двум причинам, для другого сделана, этих программистов не остановить) 2) в тех языках где этого нет ничего страшного не случается

[2:07] 
вспоминая все собеседования, думаю где то 97% людей говорит что это для защиты

vgv [2:10 PM] 
Да, для защиты

dstarcev [2:10 PM] 
я думаю инкапсуляцию как цель вообще ставить не надо

vgv [2:11 PM] 
Инвариант класса как мне защищать если я не могу скрыть внутреннюю структуру класса?

dstarcev [2:11 PM] 
ты просто придумал контракт

[2:11] 
если в контракте надо чтоб был прямой доступ к данным, ну ок пусть будет(edited)

[2:11] 
просто ничего кроме контракта не нужно

[2:12] 
не потому что нельзя, а потому что не нужно. мне так кажется

kirill.mokevnin [2:12 PM] 
Вася, я о другом

[2:14] 
имеется ввиду именно человеческий фактор

[2:15] 
я много сегодня этот пример приводил, это как final класс

[2:15] 
я про такую защиту

[2:15] 
а вдруг будут наследовать? нельзя нельзя, сделаю ка я класс final

vgv [2:15 PM] 
Да

[2:15] 
И это удобно если я не проектировал класс как предназначенный для наследования

[2:16] 
С одной строны, мне похеру

[2:16] 
Я разработал либу, а если кто-то унаследовался и получил баги - ну и плевать(edited)

kirill.mokevnin [2:16 PM] 
вот как раз final и есть той самой защитой

vgv [2:16 PM] 
с одной стороны

kirill.mokevnin [2:16 PM] 
от дурака

vgv [2:16 PM] 
а с другой - я же хочу сделать свою либу лучше

kirill.mokevnin [2:16 PM] 
ну да, и почти наверняка это приводит к тому что нормальным людям потом жить не дают

[2:17] 
потому что так задумал проектировщик либы

[2:17] 
хотя в wild мире оказалось что это не так

vgv [2:17 PM] 
Это уже от опыта зависит

[2:17] 
От опыта проектировщика, от его знания конкретного языка и принятых в нем идиом

maxim-pervushin [2:17 PM] 
joined #computer_science

vgv [2:17 PM] 
Если человек из мира Руби (условно) дизайнит либу для Java - ей 99% будет невозможно пользоваться

[2:17] 
Как и наоборот

dstarcev [2:18 PM] 
в итоге защита не от дурака, а от умного. дураку не надо ничего расширять

kirill.mokevnin [2:18 PM] 
я тут не буду бросаться на амбразуру, но мое личное мнение что сам по себе подход исходя из “я лучше знаю я проектировщик” это не правильный путь(edited)

[2:18] 
я за минимум сущностей и возможность воздействовать

[2:18] 
а дальше мы сами разберемся как разработчики

vgv [2:18 PM] 
Ну, ты сейчас перевел разговор в очень общую плоскость, тут невозможно спорить

[2:18] 
понятно, что чем меньше сущностей тем лучше

kirill.mokevnin [2:19 PM] 
ну у меня к final именно такое отношение

[2:19] 
никакого computer science это тупо мнение создателей языка что от разработчиков надо защищаться

dstarcev [2:19 PM] 
http://stackoverflow.com/questions/2169668/why-would-you-make-a-whole-class-sealed-final

Why would you make a whole class sealed/final?
I understand the motivation for making individual methods of a class sealed/final, but what purpose does completely prohibiting inheritance from the class serve? While allowing overriding of certain

kirill.mokevnin [2:21 PM] 
я так понимаю это мне?

[2:22] 
все что там написано это оправдание существования этой штуки)

[2:23] 
я когда про абстрактные классы рассказывал в php ооп я тоже их оправдывал)

[2:23] 
потому что все что они делают решается трейтами лучше и универсальнее (если они есть в языке)(edited)

dstarcev [2:25 PM] 
да там оправдания

kirill.mokevnin [2:25 PM] 
черт сегодня какой то день странный получился, пол дня в чатах

[2:25] 
хорошо что это часть моей работы :smile:

dstarcev [2:26 PM] 
можешь сохранить историю по эрлангу? мне кажется там чето крутое

[2:26] 
но не успел

[2:26] 
потом хочу почитать

kirill.mokevnin [2:27 PM] 
ребята сохранили вроде

sora [2:27 PM] 
я на всякий случай в Word сохранил :simple_smile:

kirill.mokevnin [2:27 PM] 
кстати как у тебя успехи с эрлангом?

[2:27] 
завелось работает?

sora [2:27 PM] 
Буду вечером читать - пойму 10% буду счастлив :simple_smile:(edited)

kirill.mokevnin [2:28 PM] 
сорри, я спросил у @dstarcev )

[2:28] 
а тебе еще пых надо победить :wink:

[2:29] 
хотя попрактиковаться паралелльно с эрлангом помогло бы

dstarcev [2:29 PM] 
Да все работает. но я пока только два урока прошел.

[2:29] 
там курс кстати не закончен, он будет продолжаться?

[2:30] 
я про песочный курс

endurance [2:31 PM] 
Не могу определиться куда вначале выпрыгнуть, в кложу или в эрленг

dstarcev [2:31 PM] 
можно и туда и сюда,

kirill.mokevnin [2:31 PM] 
курс не будет продолжаться

[2:32] 
там прыгать нужно буквально до “определил функцию, вызвал"

[2:32] 
это час времени

endurance [2:33 PM] 
"Неделя и в продакшн"

dstarcev [2:39 PM] 
Вот в эрланге у меня вопрос возник по кортежам и паттерн матчингу. Вот мы рекорд объявили из пяти полей. Используем его, матчимся по нему. А потом мы хотим добавить в него поле. Весь матчинг развалится? Он же позиционный

kirill.mokevnin [2:41 PM] 
да

[2:41] 
ну а если ты в функцию добавишь новый аргумент

[2:41] 
ничего не развалится?

dstarcev [2:41 PM] 
его можно сделать необязательным

kirill.mokevnin [2:41 PM] 
с record другая ситуация, по нему не надо матчится как по кортежу

[2:42] 
в таких языках нет понятия “не обязательный” у тебя просто разные клозы

[2:42] 
сделай еще один клоз

[2:42] 
и ничего не развалится

[2:42] 
было {a, b} добавилось {a, b, c}

[2:42] 
короче это прямо один в один как в функциях

dstarcev [2:42 PM] 
там в курсе вроде говорилось что при создании нового рекорда создается просто кортеж, или я что-то не так понял

kirill.mokevnin [2:42 PM] 
это не важно что внутри

[2:43] 
важно что на уровне языка это абстракция с которой тебе надо работать

[2:43] 
не уходя вниз

[2:43] 
сегодня кортеж, завтра поменяют реализацию

[2:43] 
 ```> P3 = #person{name="Joe", phone=[0,0,7], address="A street"}.
#person{name = "Joe",phone = [0,0,7],address = "A street"}
> #person{name = Name} = P3, Name.
"Joe"
```
(edited)

[2:44] 
но рекорды сейчас во многом заменены мапами

[2:44] 
не везде но много где

[2:44] 
http://www.erlang.org/doc/man/maps.html

dstarcev [2:44 PM] 
ладно, я буду дальше изучать и вероятно наступит просветление

kirill.mokevnin [2:45 PM] 
надо немного сообщения погонять и с процессами поработать

[2:45] 
а там да, понятнее станет

lisovskyvlad [3:01 PM] 
а на каком этапе добавлять OTP?)

kirill.mokevnin [3:04 PM] 
ты почувствуешь)

[3:04] 
когда станет все понятно

dstarcev [3:07 PM] 
otp это модель акторов?

kirill.mokevnin [3:08 PM] 
otp это рельсы в эрланге

[3:08] 
только для процессов

[3:08] 
существует очень много паттернов по тому как правильно и эффективно работать с процессами, разработчики языка давно реализовали otp - open telecom platform вроде

[3:09] 
это как раз уже набор готовых наработок, которые позволяют легко строить приложения на эрланговских акторах

[3:09] 
это просто код на эрланге

[3:09] 
то есть сырые процессы не используют, пользуются otp

[3:10] 
там есть такие штуки как gen_server (это типичный процесс worker), супервизоры (которые чекают другие процессы)(edited)

vladpurga [3:41 PM] 
joined #computer_science

lisovskyvlad [3:59 PM] 
и можно крутые опердени на этом делать

[4:00] 
а не ваши эти сайтики

alekseyaq [5:39 PM] 
joined #computer_science

alexelizarov [6:09 PM] 
Перечитывал наш сегодняшний и другие сохраненные разговоры про ФП. Хотелось бы вынести какой-то итог. Я для себя понял так: если нет состояния - то для таких задач подойдут лучше всего функциональные языки. Хотя на императивных тоже можно решить любую задачу (если они обладают полнотой по Тьюрингу), но все же они привносят "случайную" сложность туда, где можно использовать просто чистую функцию. Если же появляется состояние - то уже не ФП. Хотя можно остаться в рамках функциональных языков, потому что они предоставляют свои способы управлять состоянием. И иногда это даже объектно-ориентированный подход, причем в том виде, в каком его придумал Алан Кей (как в erlang). Но тут зависит от задачи. Если система где высокие требования к отказоустойчивости и где происходит межпользовательское взаимодействие - там отлично подойдут функциональные языки. Если нет таких требований - то вполне сгодятся и класс-ориентированные языки. Поправьте пожалуйста где не прав.

v.manenkov [6:11 PM] 
Класс-ориентированные -- нет такого понятия. Есть объектно-ориентированные

[6:12] 
> Если система где высокие требования к отказоустойчивости и где происходит межпользовательское взаимодействие - там отлично подойдут функциональные языки
Имелся в виду конкретно Erlang

alexelizarov [6:14 PM] 
Ну ООП в java и в erlang разное же(edited)

[6:17] 
И вот еще не понял: для калькулятора, например, лучше же все таки использовать функциональный стиль? Понятно что в императивном тоже можно написать калькулятор, но что здесь больше подойдет? Я так понимаю, что ФП? Потому что у нас же чистая функция получается - приняли строку, вернули число(edited)

v.manenkov [6:17 PM] 
> Хотя на императивных тоже можно решить любую задачу (если они обладают полнотой по Тьюрингу), но все же они привносят "случайную" сложность туда, где можно использовать просто чистую функцию.
Чистые функции можно писать и в императивных языках. Функиональные языки просто поощряют это. Решение любой задачи, решаемой в декларативном стиле (функц. подход  в частном случае) можно переписать и в императивном(edited)

alexelizarov [6:19 PM] 
Понятно что можно, но зачем? Если оно принесет дополнительную сложность. Я так понял из второго вебинара. Там где была задача по строке определить сколько в ней слов. Я понимаю что такую задачу можно и решить и функциональном стиле и в императивном. Но как лучше то? Из второго вебинара я понял что лучше в функциональном

v.manenkov [6:21 PM] 
Использование чистых функций не означает, что программа написана в функциональном стиле. Конечно, нужно стремиться чистые функции везде. Жить будет проще.

alexelizarov [6:22 PM] 
Тогда что значит в императивном стиле? Я так понимаю что императивный стиль - это если есть присваивания? Зачем нам в калькуляторе присваивания?

v.manenkov [6:22 PM] 
Как проще решать задачу, так и нужно. Если проще в функциональном -- то лучше в функциональном стиле.

[6:24] 
Императивное программирование означает в частности активное использование присваиваний.

alexelizarov [6:25 PM] 
Понятно что как проще, так и надо решать) А что если я смотри задачу и не понимаю как проще? Изначально то, еще до того как начал ее решать мне довольно сложно понять как проще будет) Понятно, что этому нужно учиться. Вот я и спрашиваю. Хотя бы на примере калькулятора.

[6:25] 
Присваивания нам там не нужны - значит проще будет в функциональном стиле решать. Или нет?

v.manenkov [6:26 PM] 
Не значит. Это зависит как минимум от языка. Насколько хорошо в нем реализована поддержка функциональных фишек

alexelizarov [6:27 PM] 
Так мы же изначально свободны в выборе языка. Зачем привязываться к языку?

[6:27] 
Если видишь что присваивания не нужны - значит лучше подойдет ФП. Вот и выбираешь язык где хорошо реализована поддержка функциональных фишек, я так понимаю

v.manenkov [6:28 PM] 
Функциональный подход означает, что задача разбивается на последовательность действий и они выполняются друг за другом. Это ФП.

[6:28] 
Сейчас найду беседу в вики.

[6:29] 
Я там написал отстойное императив-стайл решение из которого нифига не понятно, если увидеть в первый раз. У других решение в функциональном стиле, которое понять проще. Это чтобы видеть разницу.

[6:30] 
https://github.com/Hexlet/hexlet-slack-archive/wiki/%D0%A4%D0%9F-%D0%B8-%D0%BD%D0%B5-%D0%A4%D0%9F-%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BE%D0%B4%D0%BD%D0%BE%D0%B9-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8

GitHub
Hexlet/hexlet-slack-archive
hexlet-slack-archive - Архивы хороших бесед из Слака Хекслета

[6:31] 
> алгоритм 1) генерируем последовательность натуральных чисел до ста, 2) оставляем только нечетные 3) складываем их попарно 4) оставляем только те у которых в бинарном представлении количество единиц и нулей одинаковое 5) возвращаем общее количество единиц
Это требовалось запрограммировать. Решения внизу страницы

v.manenkov [6:34 PM] 
added and commented on a Clojure snippet 
(defn solution
  [n]
  (->> n
       (range 1)
       (filter odd?)
1 Comment Click to expand inline 14 lines
Пример на Clojure. Может быть он не понятен, но демонстрирует то, что мы прогоняем список через цепочку функций

v.manenkov [6:35 PM] 
в результате всё прозрачно. все действия как на ладони

alexelizarov [6:35 PM] 
да да, этот разговор тоже перечитывал. Вот там же написано, что императивный/декларативный это не плохо/хорошо - это просто разные подходы. Но те, кто владеют и тем и тем предпочитают декларативный. То есть я как понимаю, если увидел что не нужно управлять состоянием - значит больше подойдет ФП. Соответственно уже и выбираешь язык. Правильно?

dstarcev [6:36 PM] 
это так в кложе цепочки функций выглядят?

mrphantomt [6:37 PM] 
@dstarcev:  композиция функций

dstarcev [6:37 PM] 
прекрасно

[6:37] 
и никакой вложенности

v.manenkov [6:39 PM] 
Я думаю, что функциональный подход хорош для всего, кроме низкоуровневых системынх вещей и использовать его в остальных областях предпочтительнее, если если получается так писать.(edited)

[6:39] 
Лично мне трудно писать в чисто декларативном стиле

alexelizarov [6:41 PM] 
Я так понял что и не возможно написать все в декларативном стиле. Ну то есть теоретически возможно (лямбда исчисление же эквивалентно машине Тьюринга), но с практической точки зрения невозможно

v.manenkov [6:43 PM] 
Компьютеры императивны, это раз. Чисто-чисто функциональный подход это невозможность сохранить результат вычислений. Поэтому немного императивного кода всё равно будет :simple_smile:

alexelizarov [6:46 PM] 
Как невозможность сохранить результат? Рекурсия и аккумуляторы же

densom [6:46 PM] 
во вне наверное

v.manenkov [6:47 PM] 
> во вне наверное
Да, я как раз про это

alexelizarov [6:47 PM] 
а, понял

v.manenkov [6:48 PM] 
Это получается такая большая формула, по которой идут данные. Промежуточный результат получить не получится, т.к. нет присваивания

[6:49] 
Хотя я где-то читал, что есть какая-то возможность остановить процесс вычисления и продолжить его.

[6:49] 
Но это всё равно не означает, что результат можно будет получить

alexelizarov [6:54 PM] 
в целом становится понятнее, спасибо) Но очень много вещей конечно еще завесой тайны покрыты)

kirill.mokevnin [7:35 PM] 
@v.manenkov: это называется (щас попробую выговорить) континуейшены

sashashakun [10:21 PM] 
>Если же появляется состояние - то уже не ФП
Вот тут не понял. по-моему состояние есть всегда

kirill.mokevnin [10:22 PM] 
на глобальном уровне да

[10:22] 
но не на локальном

[10:22] 
болшинство кода в проекте на самом деле это чистый код

[10:22] 
который вычислениями занимается

[10:23] 
а достать из базы и положить туда, это очень маленький процент

[10:23] 
даже компилятор, это чистая функция

sashashakun [10:23 PM] 
Ну так главный вопрос же в управлении состоянием, разве нет?

kirill.mokevnin [10:23 PM] 
нет

[10:24] 
ну вот смотри cli либа

[10:24] 
берет на вход md файл и генерит по нему html

[10:24] 
все что тут про побочные эффекты это прочитать файл

[10:24] 
дальше вся логика в одном методе render

[10:24] 
который по сути чистый

[10:24] 
дальше content = render()

[10:24] 
и write(content)

[10:25] 
на самом деле тут просто плоскостей больше

[10:25] 
вопрос не в самом наличии состояния

[10:25] 
а как ты с ним работаешь

[10:25] 
если ты его меняешь в каждой функции, вот это ахтунг

sashashakun [10:26 PM] 
Это уже про управление сложностью и стоит не увеличивать сложность в ненужном месте

kirill.mokevnin [10:26 PM] 
да, на самом деле программа раскладвается

[10:26] 
просто так не мыслят

[10:26] 
в основном пытаются мыслить “давайте все на объекты поделим"

[10:26] 
правильное разделение это “побочные эффекты налево, чистый код направо"

[10:27] 
дальше, где у нас стейт

[10:27] 
а потом уже “фигачим логику и строим абстракции"

[10:27] 
в том самом чистом коде

[10:27] 
и тут выясняется что в общем то все чистое

[10:27] 
что такое http запрос почти всегда

[10:27] 
прочитал из базы, дальше логика(edited)

[10:27] 
записал в сокет

sashashakun [10:27 PM] 
Чистый код, это именно «бизнес-логика», расчеты?

kirill.mokevnin [10:28 PM] 
да

[10:28] 
сначала избавляемся от побочных эффектов

[10:28] 
потом изолируем состояние

[10:28] 
потом пишем логику

[10:28] 
многие паттерны на самом деле об этом, но слишком частные

[10:28] 
и там это косвенно подается

[10:28] 
например data mapper

alexelizarov [10:28 PM] 
А как понять "изолируем состояние"?

kirill.mokevnin [10:29 PM] 
как раз о том как отделить побочный эффект

[10:29] 
вместо activerecord

alexelizarov [10:29 PM] 
Как его можно изолировать?

kirill.mokevnin [10:29 PM] 
где он слит с сущностями

sashashakun [10:29 PM] 
избавляемся от побочных эффектов == пишем логику ?

kirill.mokevnin [10:29 PM] 
отделяем код делающий побочные эффекты от того что делает логику

[10:29] 
если у тебя есть класс markdown

[10:29] 
он не должен читать файл и его же обрабатывать

[10:30] 
он может такой метод предоставить конечно на верхнем уровне (как фасад), но внутри это два разных аспекта

sashashakun [10:30 PM] 
логику следует абстрагировать от внешних условий? типа очевидного ввода/выводв

kirill.mokevnin [10:30 PM] 
должно быть отдельно “читаем” и “обрабатываем"

[10:30] 
ввод и вывод это и есть побочные эффекты

alexelizarov [10:30 PM] 
Т.е. есть код работающий с файлом, а есть код работающий с данными из этого файла?

[10:30] 
и их надо отделять друг от друга?

kirill.mokevnin [10:30 PM] 
побочные эффекты это все что связано с io, сетью

sashashakun [10:31 PM] 
Правильный подход, я так стараюсь делать

kirill.mokevnin [10:31 PM] 
код работающий с данными работает с данными откуда угодно(edited)

[10:31] 
какая вам разница откуда поступил markdown?

[10:31] 
какая разница откуда код взялся?

[10:31] 
откуда структура user пришла

[10:31] 
и куда она потом уйдет

sashashakun [10:31 PM] 
Это делает код переиспользуемым

kirill.mokevnin [10:32 PM] 
очень тестируемым

sashashakun [10:32 PM] 
DRY, вот это все

kirill.mokevnin [10:32 PM] 
что может быть проще тестирования чистых функций

[10:32] 
я не люблю слово DRY

[10:32] 
оно следствие а не причина

[10:32] 
в том смысле что под этим понимают все что угодно

sashashakun [10:32 PM] 
во, тестирование чистых функций это хорошо и приятно

[10:32] 
баззворд такой, да)

kirill.mokevnin [10:32 PM] 
это очень прикольно когда люди из императивного мира спрашивюат как код писать

[10:33] 
в эрланге или в кложе

[10:33] 
там все ржут и говорят чуваки у нас одно правило

[10:33] 
чистый/не чистый

[10:33] 
все остальное следствия и умение строить абстракции

[10:33] 
а вот это ключ

[10:34] 
а хаскель вас заставляет так делать

densom [10:34 PM] 
всетаки не очень ясно, что значит "потом изолируем состояние".

sashashakun [10:35 PM] 
Все таки хочу вернуться к состоянию, после знакомства с чистыми функциями, идеями реакта, и курсом по основам программирования мне вообще кажется что концепция состояния и управления им это краеугольный камень программирования. То есть если мы говорим о бизнес-логике, то это может быть математика, но не программирование. В чем я не прав?

kirill.mokevnin [10:35 PM] 
берешь reactjs и angularjs

[10:35] 
ангуляр это состояние распихивает по всем своим компонентам

[10:35] 
reactjs изолирует его в одном месте

[10:35] 
с контролем доступа

sashashakun [10:35 PM] 
Я думаю «изолируем состояние» значит что нужно выделить именно меняющиеся данные вашего приложения/компонента

[10:35] 
Скорее действие в голове

[10:35] 
Которое потом реализуется в коде(edited)

kirill.mokevnin [10:35 PM] 
да нужно понять что у вас там вообще состояние

[10:36] 
где его и как хранить

[10:36] 
и как отделить от логики

[10:36] 
чтобы ваша логика делала так newState = dosomething(state)

[10:36] 
не над всем состоянием сразу конечно, а над его кусками

sashashakun [10:37 PM] 
@kirill.mokevnin: вот у меня такая мысль https://hexlet-ru.slack.com/archives/computer_science/p1452627303003695
Alexander Shakunsashashakun
Все таки хочу вернуться к состоянию, после знакомства с чистыми функциями, идеями реакта, и курсом по основам программирования мне вообще кажется что концепция состояния и управления им это краеугольный камень программирования. То есть если мы говорим о бизнес-логике, то это может быть математика, но не программирование. В чем я не прав?
Yesterday at 10:35 PM

kirill.mokevnin [10:37 PM] 
да, все что просто вычисляется можно свести к логике, алгебре, чему там еще

alexelizarov [10:38 PM] 
А GUI это всегда состояние?

kirill.mokevnin [10:38 PM] 
есть у меня один доклад который я всем реклмариую постоянно :wink:

alexelizarov [10:38 PM] 
понял какой)

[10:38] 
посмотрю

kirill.mokevnin [10:39 PM] 
@sashashakun: заметил что это шаг вперед после которого уже нет обратного пути?)

sashashakun [10:39 PM] 
Мне там понравилось в докладе упоминание кажется комбинаторики и/или теории графов в контексте управления состоянием. Я прямо вспомнил свою боль при попытке контролировать все возможные связи

[10:40] 
@kirill.mokevnin:  Теперь я постоянно думаю в таких категориях)

kirill.mokevnin [10:40 PM] 
тут недавно писали в general вроде про сложность понимания рекурсивных алгоритмов(edited)

[10:40] 
на самом деле надо чуть по другому на это смотреть

[10:40] 
не надо пытаться целиком в голове уложить его

alexelizarov [10:40 PM] 
Да, у меня иногда бывало 5 вложенных if-ов в каждом из которых по 5 проверок) и это все в двух вложенных циклах) ну это если грубо

sashashakun [10:41 PM] 
а потом смотришь на это через неделю и понимаешь что ты гдето свернул не туда)

kirill.mokevnin [10:41 PM] 
да есть над чем поработать

[10:42] 
чтобы хорошо понять про состояние, попробуйте спроектировать многопользовательскую игру в терминале

[10:42] 
сервер куда подрубаются клиенты

[10:43] 
тупую какую нибудь до безобразия

alexelizarov [10:43 PM] 
А правильно что чистый код - это не обязательно ФП? В императивном стиле тоже можно чистые функции писать(edited)

sashashakun [10:43 PM] 
У меня тут в тему https://hexlet-ru.slack.com/files/sashashakun/F0HBBT24T/__________________________2015-12-25____0.33.16.png

sashashakun [10:43 PM] 
mentioned an image: Снимок экрана 2015-12-25 в 0.33.16.png 
1 Comment
kirill.mokevnin [10:43 PM] 
ты это сделал?

sashashakun [10:43 PM] 
в процессе

kirill.mokevnin [10:43 PM] 
да и в императивном можно конечно

sashashakun [10:43 PM] 
книжку читаю

kirill.mokevnin [10:44 PM] 
например функция которая делает так increment(5)

[10:44] 
возвращает 6

[10:44] 
как ее можно сделать не чистой?)

[10:44] 
это еще надо постараться

[10:44] 
вы бы знали какой ахтунг в php творится

alexelizarov [10:45 PM] 
increment(x) {x = x + 1; return x}

kirill.mokevnin [10:45 PM] 
там просто недосягаемый уровень побочных эффектов(edited)

alexelizarov [10:45 PM] 
Это будет не чистая?

kirill.mokevnin [10:45 PM] 
чистая, то что внутри не важно, это локальное состояние которое уходит после выполнения функции

[10:45] 
главное что снаружи

sashashakun [10:45 PM] 
чистая

alexelizarov [10:45 PM] 
а, понял

[10:45] 
о, кажется щелкнуло прям

kirill.mokevnin [10:45 PM] 
не чистая это если increment(x) // x= 5;

[10:46] 
и вдруг x == 6

[10:46] 
без всяких return

sashashakun [10:46 PM] 
Чистая не зависит ни от чего кроме своих аргументов и никак не влияет на окружающий код. Никуда не пишет, никуда не ходит, etc.

[10:46] 
просто передал что-то в нее, получил результат от нее, и все

[10:47] 
я так понимаю

kirill.mokevnin [10:47 PM] 
формально это означает что результат функции зависит только от аргументов и функция не делает побочных эффектов (side effects)

[10:47] 
вопрос такой

[10:47] 
а если получили эту функцию замыканием?

dstarcev [10:47 PM] 
Я думал что чистая - это результат которой при одинаковых аргументах всегда одинаковый

alexelizarov [10:48 PM] 
ага) что бы сделать ее не чистой надо глобальную константу объявить inc = 1. и в функции increment эту константу к аргументу прибывлять

kirill.mokevnin [10:48 PM] 
это можно сказать детерменированная

alexelizarov [10:48 PM] 
Тогда будет не чистая?

kirill.mokevnin [10:48 PM] 
но это понятие само по себе

sashashakun [10:48 PM] 
в каком смысле «получили замыканием»?

kirill.mokevnin [10:48 PM] 
ну вот функция замкнула что то в себе

[10:48] 
чистая она или нет

[10:48] 
?

alexelizarov [10:49 PM] 
Нет наверное

kirill.mokevnin [10:49 PM] 
почему?

[10:49] 
она обладает всеми свойствами

sashashakun [10:49 PM] 
Так, а причем тут замкнула или нет?

alexelizarov [10:49 PM] 
Потому что уже не только от своих параметров зависит

kirill.mokevnin [10:49 PM] 
вот в этом вопрос

[10:49] 
можно ли эту фразу сюда применить или нет

[10:50] 
для начала прочитайте что такое референциальная прозрачность

[10:50] 
должно помочь

atosdo [10:50 PM] 
ну пусть замкнула - если это не влияет ни на что за ее пределами - то на здоровье )

kirill.mokevnin [10:50 PM] 
так то да, но где доказательство? :wink:

[10:50] 
мы в computer science

[10:50] 
на самом деле не всегда

sashashakun [10:51 PM] 
Формально можно получить что нибудь типа 
closureFunc() == 2 // true
closureFunc() == 4 // true
и это нифига не чисто)

kirill.mokevnin [10:51 PM] 
есть языки в которых замыкание не по значению

[10:51] 
да, мы про замыкание переменной

[10:51] 
а не про замыкание не чистой функции)

[10:51] 
там то все понятно

[10:51] 
что функция будет не чистая

sashashakun [10:53 PM] 
added a Plain Text snippet: Я вам немножко замыкания принес 
function sequence(start, step) {
        var start = start || 0;
        var step = step || 1;
        return function () {
Add Comment Click to expand inline 11 lines
sashashakun [10:53 PM] 
Я так понял речь о подобном

kirill.mokevnin [10:54 PM] 
не совсем

[10:54] 
если ты функцию через замыкание делаешь не чистой это очевидно и понятно

[10:54] 
а вот именно в том случае когда ты замыкаешь значение

[10:54] 
которые гарантированно не меняется

[10:54] 
и функция вроде как чистая

[10:54] 
но можно ли сказать что она зависит только от своих параметров?

[10:55] 
ответ на самом деле очевидный, но когда не знаешь (и плаваешь в теме) можно перемудрить)

[10:55] 
хотя все просто

dstarcev [10:55 PM] 
Если функция замкнулась на неизменяемое значение, то это все равно что написать просто функцию и определить в ней константу

sashashakun [10:55 PM] 
Если это значение не меняется в теле ф-и

[10:56] 
И если он него не зависит ответ

dstarcev [10:56 PM] 
Просто при замыкании эта константа в рантайме определяется при создании функции

kirill.mokevnin [10:56 PM] 
именно, более того, по сути функция и была сгенерирована

sashashakun [10:56 PM] 
Но когда зачем оно там вообще?)

kirill.mokevnin [10:56 PM] 
можно сказать что определение функции динамическое

dstarcev [10:56 PM] 
Да

v.manenkov [10:56 PM] 
В Racket функции замыкаются на изменяемые значения. Там даже можно шарить переменную между двумя замыканиями так. Это во всех фп языках так?

kirill.mokevnin [10:56 PM] 
ракет не фп язык

[10:57] 
лиспы вообще не фп языки

[10:57] 
в фп языках нет переменных

sashashakun [10:57 PM] 
Шарить между замыканиями? Не знаю зачем это, но по-моему очень круто:)

kirill.mokevnin [10:57 PM] 
в лиспах есть императивность прямо классическая

[10:57] 
с переменными, присваиванием (в виде функции set!)

[10:58] 
и в сикпе это разбирается во всю

[10:58] 
в третьей главе после середины

[10:58] 
там даже циклы есть

[11:00] 
так вот про php хотел сказать)

[11:00] 
представьте такое

[11:00] 
делаешь get_headers(url)

[11:01] 
ой вру, делаешь file_get_contents(url)

[11:01] 
он возвращает body

[11:01] 
смотришь доку, как получить хедеры

[11:01] 
вы никогда не догадаетесь

[11:01] 
какой способ они выбрали

[11:01] 
кто угадает?)

netxor [11:02 PM] 
Прохожу 8-й урок в php: основы программирвания, и не пойму, зачем создавать ф-цию sumGenerator когда я могу просто базовую функцию передать в качестве аргумента?

dstarcev [11:02 PM] 
Глобальная переменная?

kirill.mokevnin [11:03 PM] 
кстати интересно, глобальная она или нет

[11:03] 
но да `$http_response_header`

[11:03] 
вот такая переменная внезапно врывается в код

netxor [11:03 PM] 
и передавать причем ее каждый раз

[11:03] 
по новой

[11:03] 
с разными условиями

dstarcev [11:03 PM] 
А разве можно в локальный скоуп что-то впихнуть из дочернего вызова?

netxor [11:04 PM] 
например, складываемый интеджер или кубов

kirill.mokevnin [11:04 PM] 
я просто в тонкостях php не силен

[11:04] 
@netxor: а можно пример?

[11:04] 
пока не понял о чем речь

sashashakun [11:04 PM] 
Так что там с file_get_contents(url)?

kirill.mokevnin [11:05 PM] 
вопрос был в том что можно просто каждый раз вызывать sumGenerator и туда передавать эту функцию?

sashashakun [11:05 PM] 
доку не смотрел, функция делает http запрос?

kirill.mokevnin [11:05 PM] 
"​[11:03] 
но да `$http_response_header`

​[11:03] 
вот такая переменная внезапно врывается в код"

[11:05] 
просто появляется переменная

[11:05] 
из ниоткуда

sashashakun [11:05 PM] 
аа, понятно

densom [11:09 PM] 
я не понимаю, все-таки, почему php самый распространеный в вебе по факту, если я не ошибаюсь. Значит все-таки это работает в жизни и в таком хитром виде.

sashashakun [11:09 PM] 
потому что простой(edited)

kirill.mokevnin [11:09 PM] 
не простой

[11:09] 
он щас такой сложный что мало не покажется

sashashakun [11:09 PM] 
легко начать

kirill.mokevnin [11:09 PM] 
вот это да

[11:09] 
вы просто пишете файл index.php

[11:10] 
делаете echo ‘my html'

sashashakun [11:10 PM] 
Он же вообще задумывался как язык шаблонов

kirill.mokevnin [11:10 PM] 
и человеку уходит html

[11:10] 
все!

sashashakun [11:10 PM] 
Можно запиливать html прямо посреди кода

alexelizarov [11:10 PM] 
В jcp тоже можно это делать

[11:11] 
jsp

sashashakun [11:11 PM] 
Одной строкой?

alexelizarov [11:11 PM] 
Там и начинать тоже по-моему не сложно

sashashakun [11:11 PM] 
jsp в java-мире не комильфо нынче, хотя могу ошибаться

kirill.mokevnin [11:12 PM] 
у вас там реально index.php содержит одну строку

alexelizarov [11:12 PM] 
Ну там же тоже специальные теги просто надо прописать. Не <?php ?> а какие то другие

kirill.mokevnin [11:12 PM] 
echo ‘<html>….'

alexelizarov [11:12 PM] 
не понмю точно какие

kirill.mokevnin [11:12 PM] 
одну!

[11:12] 
ни одной либы

[11:12] 
ничего вообще

[11:12] 
дальше просто подключились к nginx или apache

[11:12] 
и все

netxor [11:12 PM] 
к примеру есть базовая функция по нахождению складываемых переменных
function sum($a, $b, $func) {
 if ($a > $b) { return 0; }
 return $func($a) + sum($a + 1, $b, $func);
}

далее функция снаружи, которая описывает каким образом будет вычислятся в базовой функции

$identity = function($x) { return $x; };

и затем уже выводим на экран

echo sum(1, 5, $identity);

То есть, мы можем менять возращаемый результат выражения каждый раз и передавать ее в качестве аргумента снова и снова

$sumOfCubes = function($x) { return $x * $x * $x; }
echo sum(1, 5, $sumOfCubes);

и зачем мне заморачиваться с возвратом функции как значения, как в примере 8-го урока создавай sumGenerator?

kirill.mokevnin [11:12 PM] 
а для тех кто юзает шаред хостинг они просто копируют этот файл на хостинг

[11:12] 
называют его правильно: index.php

[11:12] 
и вот сайт

john_mephistophilus [11:13 PM] 
профит)

netxor [11:13 PM] 
сорри, надо было в соотвествующем разделе задать

kirill.mokevnin [11:14 PM] 
дело в том что там просто механика работы показана

[11:14] 
представьте что не вы этой функцией пользуетесь

[11:14] 
а вы специфицируете ей код

dstarcev [11:14 PM] 
что-то тут не так

kirill.mokevnin [11:14 PM] 
человеку который будет этим пользоваться не надо знать про все эти особенности

[11:14] 
банальный пример, вот у вас есть логгер

[11:15] 
и первым параметром в него надо ip передать

[11:15] 
и он передается в глубь вашего приложения где нет никаких ip(edited)

[11:15] 
что вы можете сделать чтобы оно работало?

[11:15] 
вы можете таскать за собой везде этот ip(edited)

[11:15] 
в каждую функцию

[11:16] 
и делать вызов log(ip, <что нибудь>)

[11:17] 
а можете сделать частичное применение и сгенерировать функцию которая уже замыкает внутри себя ip

[11:17] 
а внутрь передавать функцию log с одним аргументом

[11:17] 
log(что то) - ip уже внутри

[11:17] 
это один из тыщи вариантов применения

sashashakun [11:18 PM] 
Сначала подумал что это не очевидно, но можно же посмотреть как происходит частичное применение

kirill.mokevnin [11:18 PM] 
делается это так например log-with-ip = partial-apply(log, ip)(edited)

[11:19] 
и дальше везде достаточно писать log-with-ip(string)

[11:19] 
иногда это просто тупо сокращает код

[11:19] 
чтобы 20 раз одно и тоже не передавать

[11:20] 
но более крутые примеры, это генерация спец методов

[11:20] 
https://github.com/Engelberg/instaparse

GitHub
Engelberg/instaparse
Contribute to instaparse development by creating an account on GitHub.

[11:20] 
вот яркий пример таких либ

[11:20] 
(def as-and-bs
 (insta/parser
   "S = AB*
    AB = A B
    A = 'a'+
    B = 'b'+"))

[11:20] 
эта либа генератор парсеров

[11:20] 
вы передаете в функцию insta/parser описание грамматики текстом

[11:21] 
она вам возвращает парсер

[11:21] 
дальше пример использования

[11:21] 
=> (as-and-bs "aaaaabbbaaaabb")

[11:21] 
и на выходе ast дерево

[11:21] 
[:S
[:AB [:A "a" "a" "a" "a" "a"] [:B "b" "b" "b"]]
[:AB [:A "a" "a" "a" "a"] [:B "b" "b"]]]

[11:21] 
осталось написать логику и ваш компилятор готов)

sashashakun [11:21 PM] 
логику?

kirill.mokevnin [11:21 PM] 
ну аст дерево надо как то выполнить

sashashakun [11:22 PM] 
аа, ясно

kirill.mokevnin [11:22 PM] 
это мысль уже дальше пошла)

[11:22] 
это ведь тоже можно свести к частичному применению, но тут на самом деле вступает в дело оптимизация

[11:23] 
если было бы просто частичное применение он бы каждый раз грамматику разбирал

[11:23] 
а тут (наверное) оно эту грамматику парсит, по любому еще ошибки обрабатывает

[11:23] 
и получившаяся функция уже готовый парсер

[11:23] 
убедительный пример?

densom [11:24 PM] 
это все чтобы быстрее разрабатывать ?

alexelizarov [11:24 PM] 
Я что-то совсем потерял нить( это пример чего?

dstarcev [11:24 PM] 
это конструктор))

kirill.mokevnin [11:24 PM] 
возврат функции. Зачем это нужно и где применятся(edited)

v.manenkov [11:24 PM] 
Это всё про частичное применение. Пример посложнее примера с ip :simple_smile:

sashashakun [11:25 PM] 
крутой пример

dstarcev [11:25 PM] 
конструктор парсера(edited)

kirill.mokevnin [11:25 PM] 
да можно назвать их конструкторами

[11:25] 
или еще говорят генераторами

[11:25] 
кстати помните выше говорили про стейт

[11:25] 
есть он тут или нет, вот по сути нет

netxor [11:26 PM] 
запутался, сложный пример(

v.manenkov [11:26 PM] 
Ещё бы, тут надо понимать хотя бы поверхностно суть компиляторов

[11:27] 
Для чего нужен парсер и т.д.

netxor [11:27 PM] 
можешь плз объяснить на простом примере?

[11:27] 
на уровне тех же уроков по php

[11:28] 
складывается такое ощущение, как будто-бы 8-й урок освещен не полностью

v.manenkov [11:28 PM] 
Вряд ли, я не сумел написать интерпретатор даже

[11:28] 
лиспа

kirill.mokevnin [11:28 PM] 
ну вот смотри, тебе надо рендерить маркдаун

[11:28] 
в приложении

[11:28] 
есть функция generateMarkdownParser

[11:29] 
точнее так, может быть функция generateHtmlFromMarkdown

[11:29] 
которая на вход принимает десяток параметров

[11:29] 
какие и как рендерить

[11:29] 
я это не придумал, там действительно десятки параметров

[11:29] 
и вот у тебя одна конфигурация для всего проекта

[11:29] 
а делать это надо часто и везде

[11:30] 
можно в каждом месте вызывать generateHtmlFromMarkdown(options, markdown)

[11:30] 
а можно сделать parser = generateMarkdownParser(options)(edited)

[11:30] 
и дальше везде только parser(markdown)(edited)

alexelizarov [11:30 PM] 
Это каррирование?

v.manenkov [11:31 PM] 
Это замыкание

kirill.mokevnin [11:31 PM] 
это не каррирование

[11:31] 
это частичное применение функции

densom [11:32 PM] 
это даже не рефакторинг, это какое-то упрощение, что-ли

kirill.mokevnin [11:32 PM] 
например если была функция do(a, b, c, d)

[11:33] 
то кариррирование этой функции делает функцию(edited)

[11:33] 
do(a)(b)(c)(d)

[11:33] 
в хаскеле все функции кариррованы

[11:33] 
мы недавно тут это обсуждали, какие фантастически возможности это рождает

[11:33] 
покажу пример

[11:33] 
map (+ 2) [1, 2, 3]

alexelizarov [11:33 PM] 
А я думал будет do(do2(b,c,d))

kirill.mokevnin [11:33 PM] 
к чему приведет?

[11:34] 
эх весь день пропал сегодня на разговоры :smile:

alexelizarov [11:34 PM] 
3 4 5?

kirill.mokevnin [11:34 PM] 
чо то сегодня звезды чтоли встали не так, всех потянуло поболтать

[11:34] 
да, а как это работает?

[11:34] 
эквивалент в других языках представляете?(edited)

praytic [11:35 PM] 
только с помощью лямбда выражений

alexelizarov [11:35 PM] 
в java не представляю. А в других совсем опыта почти не имею

sashashakun [11:35 PM] 
Да, а в чем проблема то? Ну тоесть + 2 передать как аргумент нельзя, но 2 и «+» легко,  а там дальше switch и все дела

densom [11:35 PM] 
ary.map(){} в ruby

alexelizarov [11:36 PM] 
Ну хотя в java мне кажется не сложно такое написать самому

sashashakun [11:36 PM] 
хотя стоп, это же map

praytic [11:36 PM] 
>Да, а в чем проблема то? Ну тоесть + 2 передать как аргумент нельзя, но 2 и «+» легко,  а там дальше switch и все дела
боль

sashashakun [11:36 PM] 
я перемудрил, это легче можно сделать в js

kirill.mokevnin [11:36 PM] 
`sum = foldr (+) 0`   `sum [1, 2, 3]`   `= 6`(edited)

[11:36] 
а вот так?)

dstarcev [11:37 PM] 
> do(a)(b)(c)(d)
в Скале тоже так

sashashakun [11:37 PM] 
reduce, не?

[11:37] 
вот этот последний пример

kirill.mokevnin [11:37 PM] 
@dstarcev: скала это хаскель с ооп закосом

[11:37] 
учить надо хаскель

[11:37] 
есть такая шутка известная что даже для объяснения монад, скалисты пользуются хаскелем

[11:38] 
на самом деле это правда, первоисточник это хаскель

[11:38] 
смотри его, познаешь скалу и все остальное

[11:38] 
это reduce да

[11:38] 
но ничего не смущает?

[11:38] 
sum = foldr (+) 0(edited)

[11:38] 
определение функции sum

[11:38] 
как так?

sashashakun [11:38 PM] 
да,  я вообще не понимаю что тут происходит

kirill.mokevnin [11:38 PM] 
определение функции(edited)

[11:38] 
fun = body

alexelizarov [11:39 PM] 
функция которая принимает функцию

[11:39] 
ФВП получается?

sashashakun [11:39 PM] 
ну да, вот это что такое foldr (+) 0`?

kirill.mokevnin [11:39 PM] 
там ничего про принимает функцию нет

alexelizarov [11:39 PM] 
я думал + это функция

kirill.mokevnin [11:39 PM] 
map (+ 2) [1, 2, 3]

[11:39] 
давайте это разберем чтобы понять

sashashakun [11:39 PM] 
Это действие

[11:39] 
Которое необходимо произвести

[11:40] 
Не знаю как это в терминах того языка, на котором этот пример

v.manenkov [11:40 PM] 
функция с параметрами через пробел. Это на Хаскеле

kirill.mokevnin [11:40 PM] 
Prelude> zipWith (+) [1, 2, 3] [2, 6, 4]
[3,8,7]

[11:40] 
это да, вопрос в том что такое (+) или (+ 2) ?

densom [11:40 PM] 
оператор и аргумент

sashashakun [11:40 PM] 
тело функции?

v.manenkov [11:41 PM] 
+  функция; 2 аргумент

kirill.mokevnin [11:41 PM] 
это вызов функции +

sashashakun [11:41 PM] 
Я думаю для этого есть неизвестный мне термин, но самое близкое это функция

[11:41] 
аа

[11:41] 
ясненько)

kirill.mokevnin [11:41 PM] 
это кстати еще один классный пример того что функции лучше операторов

[11:41] 
у вас куча новых возможностей появляется

alexelizarov [11:41 PM] 
ааа не передача а вызов?

kirill.mokevnin [11:41 PM] 
в общем в хаскель функция может быть инфиксная

[11:41] 
1 + 2

v.manenkov [11:41 PM] 
(+) [1, 2, 3] [2, 6, 4]
[3,8,7] а вот это берет [1, 2, 3] возвращает замыкание и далее берет следующий список

kirill.mokevnin [11:41 PM] 
но вообще говоря по дефолту они все префиксные

[11:41] 
+ 1 2

[11:42] 
короче прямо лисп

alexelizarov [11:42 PM] 
интересно.. вызов функции там где обычно параметры идут

kirill.mokevnin [11:42 PM] 
есть часть зарезервированных символов которые можно в инфиксном использовать

[11:42] 
это например +

sashashakun [11:42 PM] 
Так, тогда что все вот это sum = foldr (+) 0`? Объявляем sum, + это вызов функции, а foldr и  0?

kirill.mokevnin [11:42 PM] 
а вот кастомные функции можно вот так 2 \`sum\` 3(edited)

[11:42] 
блин) как апостроф написать

alvpot [11:42 PM] 
это не вызов, а передача функции как параметр

netxor [11:43 PM] 
сижу и сравниваю код с 7-го и 8-го урока

alexelizarov [11:43 PM] 
Я же говорил что передача ф-ии, мне сказали что неправильно

kirill.mokevnin [11:43 PM] 
в общем любая функция карирована

[11:43] 
это значит что (+ 1)

[11:43] 
что делает?

alexelizarov [11:44 PM] 
хотя я тоже не понимаю, как там можно вызвать ф-ии? А как тело тогда написано? как в теле сообщить какая именно ф-ия вызвана?

v.manenkov [11:44 PM] 
прибавляет 1 к следующему аргументу

alvpot [11:44 PM] 
(+ 1) - возвращает функцию

densom [11:44 PM] 
foldr :: (a -> b -> b) -> b -> [a] -> b
base Prelude, base Data.List
foldr, applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:

> foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
1  

kirill.mokevnin [11:44 PM] 
по сути у вас получается increment = (+ 1)

[11:44] 
дальше 2 = increment 1

alexelizarov [11:44 PM] 
А если бы мы написали (* 2)?

kirill.mokevnin [11:45 PM] 
Prelude> let increment = (+ 1)
Prelude> increment 2
3

[11:45] 
Prelude> let multi = (* 2)
Prelude> multi 8
16

[11:45] 
а какая разница?

[11:45] 
это общий принцип

[11:45] 
не важно сколько аргументов

[11:45] 
вы всегда получите -1 функцию по аргументам

[11:45] 
поэтому типы в хаскеле вот так выглядят foldr :: (a -> b -> b) -> b -> [a] -> b

[11:45] 
стрелками

[11:46] 
множество функций от одного аргумента выстроенных в цепочку

alexelizarov [11:46 PM] 
Интересно как это в теле ф-ии описано? Там же надо как то сослаться на этот вызов?

kirill.mokevnin [11:46 PM] 
нет

[11:46] 
вот же выше тело

[11:46] 
let increment = (+ 1)

alexelizarov [11:46 PM] 
что бы когда (+ 2) происходило сложение, когда (* 2) умножение. А как же тогда?

netxor [11:46 PM] 
и вижу что по сути пропадает необходимость передавать ф-цию которая снаружи в качестве аргумента в момент вывода на экран, более того, нет необходимости выводить базовую функцию т.к. она возвращается в функции генераторе

kirill.mokevnin [11:46 PM] 
внутри тоже самое, это делается на уровне компилятора языка

[11:46] 
что он все карированием делает

[11:47] 
ну смотрите, щас покажу пример другой

v.manenkov [11:47 PM] 
И что же в итоге каррирование открывает для разработчиков?

kirill.mokevnin [11:47 PM] 
Prelude> let sumTree a b c = a + b + c
Prelude> let sumTwo = sumTree 1
Prelude> let sumOne = sumTwo 2
Prelude> sumOne 4
7

[11:48] 
очень много, у вас частичное применение становится повседневной техникой

[11:48] 
map (+ 2) [1, 2, 3] нигде так коротко не напишите

[11:48] 
zipWith (+) [1, 2, 3] [2, 6, 4]

[11:48] 
еще один пример

alexelizarov [11:49 PM] 
Тут ведь получается что sumTwo сама стала ф-ей? только уже от двух параметров, правильно?

kirill.mokevnin [11:49 PM] 
да

[11:49] 
но я мог бы и сразу сделать sumOne = sumTree 1 2

[11:50] 
теперь еще одна неявная штука которая идет следствием из каррирования

[11:50] 
теперь понятно как это работает?
```Prelude> let sum = foldr (+) 0
Prelude> sum [1, 2, 5, 10]
18
```
(edited)

v.manenkov [11:50 PM] 
> Тут ведь получается что sumTwo сама стала ф-ей? только уже от двух параметров, правильно?
Да. Но от 1-го опять же. Но она вернет функцию ещё от одного

[11:50] 
Да

kirill.mokevnin [11:50 PM] 
фишка в том что вам не важно от одного или нет

alexelizarov [11:50 PM] 
Ну да, а можно и сразу sumTree 1 2 3?

kirill.mokevnin [11:50 PM] 
вы можете ее вызывать от одного, а можете ото всех сразу

[11:50] 
в этом крутизна

alexelizarov [11:50 PM] 
Сколько хотим столько и передаем аргументов?

kirill.mokevnin [11:51 PM] 
вот выше в fold передали два аргумента

[11:51] 
сразу

[11:51] 
в итоге она вернула функцию от одного аргумента

[11:51] 
которую мы назвали sum

[11:51] 
а дальше она ждет этот третий аргумент список

[11:51] 
в этом отношении с хаскелем никто не сравнится, даже кложа не сравнится

[11:52] 
заметьте при этом, что на базовом фп уровне (где одни чистые функции, хаскель очень просто)

alexelizarov [11:52 PM] 
т.е потом sum[1 2 3 4] это уже все равно что sum[+ 1 2 3 4]?

kirill.mokevnin [11:52 PM] 
там сложно начинается когда про сайд эффекты разговор

[11:53] 
это тоже самое что fold (+) 0 [1 2 3 4]

[11:53] 
заметьте что мы тут кариррование поверх кариррования используем

[11:53] 
потому что (+)  еще в fold передали

[11:53] 
попробуйте сделать на других языка тоже самое, получится сильно больше кода

[11:53] 
и мусора

[11:54] 
кстати вот такая штука, когда аргумент у функции не пишется, потому что на выходе функция принимающая этот аргумент - называется бесточечный стиль

[11:54] 
http://fprog.ru/2010/issue4/denis-moskvin-compositions-sections/

[11:54] 
https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/ch3.md воу)

GitHub
MostlyAdequate/mostly-adequate-guide
mostly-adequate-guide - Mostly adequate guide to FP (in javascript)

[11:55] 
https://github.com/MostlyAdequate/mostly-adequate-guide-ru фига!

GitHub
MostlyAdequate/mostly-adequate-guide-ru
mostly-adequate-guide-ru - Mostly adequate guide to FP (in javascript, translated in russian)

netxor [11:55 PM] 
и еще вопрос

kirill.mokevnin [11:56 PM] 
ладно ребят, спать, всем спасибо, сегодня был день больших мозгосмещений)
11  

netxor [11:56 PM] 
когда пишем function(арг1, и т.д.)

[11:56] 
без названия

[11:56] 
это особенность  php понимать какая ф-ция имелась ввиду

[11:56] 
?

alexelizarov [11:57 PM] 
@kirill.mokevnin: Спасибо большое за разъяснения!
6  


----- Today January 13th, 2016 -----
sora [12:22 AM] 
@netxor: Анонимные функции, есть почти везде.
3  

bmik9898 [1:14 AM] 
joined #computer_science. Also, @kalmykov joined, @jllfsh joined.

kirill.mokevnin [10:10 PM] 
https://juxt.pro/radar.html
JUXT - a software development and consulting firm focussing on effective delivery empowered by the Clojure and ClojureScript programming languages.

[10:10] 
какая интересная штука

sashashakun [10:11 PM] 
прикольно

[10:12] 
я так понимаю кложа это для желающих писать на лиспе в продакшн?

dstarcev [10:13 PM] 
Adopt
Trial
Assess
Hold

[10:13] 
не пойму что это значит

kirill.mokevnin [10:13 PM] 
да, и кложа это действительно прорыв

[10:13] 
она активно используется в продакшене

[10:13] 
и не только она но еще и clojurescript

[10:13] 
особенно с реактом

[10:14] 
кстати вы видели сравнение js и clojurescript?

[10:14] 
там прямо рядом примеры

[10:14] 
очень круто видно разницу

[10:14] 
щас загуглю, а так у меня много знакомых на кложе пишет за деньги

sashashakun [10:15 PM] 
там же написано

dstarcev [10:15 PM] 
https://www.youtube.com/watch?v=yQSbFlcIDUQ
YouTube
DublinJS
ClojureScript vs JavaScript (ES5 & ES6) - Oliver Mooney
  

sashashakun [10:15 PM] 
про 
Adopt
Trial
Assess
Hold

[10:15] 
Rings

We use the same rings as ThoughtWorks do: hold, assess, trial and adopt.

Hold means that we are holding off using this technology for now for some given reason. It may be a library that we consider simply too raw and new, or it could be a tool that we had issues with in the past and that there are valid alternatives.

Assess means that we think this libary is worth checking out, but we don't consider to be an automatic choice. It may be a new library that we haven't used but wish to, or one that you should definitely weigh up the pros and cons for.

Trial means go try this library. It may still be new or there may be cases where it's not entirely suitable, but if it in anyway fits your problem case, then you should give it strong consideration.

Adopt this is a library that we have used in anger and is a solid choice.

dstarcev [10:15 PM] 
аа

[10:15] 
чукча не читатель - чукча писатель...

kirill.mokevnin [10:17 PM] 
во https://kanaka.github.io/clojurescript/web/synonym.html

dstarcev [10:17 PM] 
// No native implementation

[10:17] 
так не честно, есть же бабель

kirill.mokevnin [10:17 PM] 
это очень старая статья

[10:18] 
если бы туда es6 воткнули, ситуация была бы чуть лучше

dstarcev [10:19 PM] 
кто знает как устроены неизменяемые словари?

[10:19] 
мне интересно копируются они при добавлении элемента или нет

kirill.mokevnin [10:20 PM] 
ты про то как это в кложе работает?

dstarcev [10:20 PM] 
ну например да

kirill.mokevnin [10:20 PM] 
рич хики реализовал в кложе (это первый язык такой) персистентные структуры данных

[10:20] 
которые потом накопировали во все языки

[10:20] 
грубо говоря любая структура данных внутри это как гит

[10:20] 
дерево

[10:20] 
любое изменение добавляет новый коммит

[10:21] 
http://habrahabr.ru/post/113585/ пример

Персистентные структуры, часть 1: персистентный стек
Я заметил, что на хабре было достаточно много постов о таких классических структурах данных, как стек, очередь, хип; рассматривались так же дерево отрезков и...

[10:21] 
реализация под js https://facebook.github.io/immutable-js/

[10:21] 
которую кстати активно юзают с реактом и мы в том числе

dstarcev [10:22 PM] 
ну стек это слишком очевидно))

kirill.mokevnin [10:22 PM] 
https://en.wikipedia.org/wiki/Persistent_data_structure

dstarcev [10:22 PM] 
обычный список же

kirill.mokevnin [10:22 PM] 
неа

[10:22] 
стек тоже в дерево превращается

sashashakun [10:24 PM] 
http://habrahabr.ru/post/113585/

kirill.mokevnin [10:24 PM] 
выше скинул

sashashakun [10:24 PM] 
не увидел)

dstarcev [10:29 PM] 
честно прочитал, не понял в чем  отличие от односвязного списка неизменяемого. если мы на один хвост прилепим две разных головы, у нас так же получится два "бранча"

kirill.mokevnin [10:29 PM] 
ну да и получается дерево

[10:30] 
в общем главное что не происходит полного копирования

dstarcev [10:30 PM] 
да я думал что дерево это когда две стрелки из одной вершины

kirill.mokevnin [10:30 PM] 
и в целом практически ничего не копируется

dstarcev [10:30 PM] 
это да

kirill.mokevnin [10:30 PM] 
они достаточно эффективны

[10:31] 
в английской вики подробно рассмотрено

[10:33] 
кстати вот мы крутимся всегда вокруг базовых штук, связанных с фп

[10:33] 
а там ведь дальше миллион всего интересного

[10:33] 
транзакционная память, логическое программирование, core.async

[10:34] 
в кложе транзакции есть в коде

[10:34] 
настоящие

[10:34] 
где код перевыполняется если появился race

[10:34] 
атомы с управляемым изменением состояния

[10:34] 
ух

dstarcev [10:34 PM] 
так кто у нас тут гуру) все ждут проповеди

egorbulychev [10:34 PM] 
joined #computer_science

kirill.mokevnin [10:35 PM] 
ага будут потом говорить “опять там этот фанатик вещает” :smile:

dstarcev [10:36 PM] 
польза есть от всего этого, что бы кто ни говорил

kirill.mokevnin [10:37 PM] 
кстати, расскажи, повлияло ли как то на твои рабочие будни то что ты тут узнал?

[10:37] 
я переодически опрашиваю наших активистов)

[10:37] 
интересно знать, во что в итоге выливаются наши усилия

[10:38] 
я кстати при этом не понял зачем ты php учишь

igrishaev [10:41 PM] 
есть распространенное заблуждение, что если структура неизменяемая, то при передаче в функцию она копируется

[10:42] 
это не так, если что.

dstarcev [10:46 PM] 
я активно  на хекслете не так давно, так что пока рано делать выводы. Но  чем больше я учусь, тем больше уверенности что  я в любую незнакомую штуку могу залезть и разобраться в ней без особых проблем. Раньше у меня как-будто блок был - типа технология незнакомая и всё

[10:47] 
а касаемо работы, я в новогодние праздники на стольких языках писал, что когда вернулся на работу, понял что как-то подзабыл сишарп)

sashashakun [10:47 PM] 
Интересно было бы увидеть какую-нибудь хардкорную теорию на хекслете(edited)

[10:47] 
Матан там какой-нибудь)

[10:48] 
Я думаю что это плохо монетизируется, но тем не менее)

dstarcev [10:48 PM] 
ну вот реакт скоро буду на работе юзать

sashashakun [10:49 PM] 
И да, матана и иже с ним полно на степике, но я устал ходить по куче ресурсов, чтобы получить желаемое

dstarcev [10:50 PM] 
еще я понял, что в работе неосознанно стремился к функциональному подходу в какой-то степени

sashashakun [10:51 PM] 
Я вот хотел бы переписать текущий проект на реакт, но времени категорически нет, пока перешел с requirejs, es3 и отсутствия тестов на webpack, babel, karma, mocha, phantomjs. Вклад хекслета в ускорении движения к тестированию)(edited)

dstarcev [10:52 PM] 
еще я хотел законтрибутить в один плагин к rabbitmq, а он на эрланге. Думаю, что курс и чатик мне поможет это сделать

[10:53] 
короче, везде по чуть-чуть, но польза есть. Где-то общее развитие, а где-то и конкретные навыки. И главное - общение. В общем, очень я рад, что попал сюда

kirill.mokevnin [10:54 PM] 
@rakhim: )

[10:54] 
Рахим собирает отзывы :wink:

dstarcev [10:54 PM] 
хех, ну это надо будет нормально сформулировать тогда)

sashashakun [10:55 PM] 
«везде по чуть-чуть, но польза есть. Где-то общее развитие, а где-то и конкретные навыки. И главное - общение. В общем, очень я рад, что попал сюда"

[10:55] 
норм?)

dstarcev [10:55 PM] 
ну хз))

kirill.mokevnin [10:57 PM] 
)
