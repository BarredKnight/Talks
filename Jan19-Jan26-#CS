
dsdolzhenko [8:32 AM] 
joined #computer_science. Also, @id25 joined.

yel1owstone [1:10 PM] 
what is it? http://steshaw.org/plt/

jougene [1:20 PM] 
added a Plain Text snippet 
(define (pow b n)
  (define (iter npow res)
    (cond ((= npow 0) res)
          ((even? npow)
           (iter (/ npow 2)
Add Comment Click to expand inline 9 lines
jougene [1:20 PM] 
вопрос - что не так, алгоритм не доделывает 2 шага.

[1:21] 
2^2 вообще говорит 8

[1:22] 
надо разобраться, я что-то недопонял

[1:22] 
опять эта итерация

cthulhu [1:29 PM] 
у тебя в ветка для четной степени неправильно написана

[1:30] 
а ну и нечетная тоже :smiley:

jougene [1:31 PM] 
блин

yel1owstone [1:37 PM] 
по-моему ветки написаны верно, а вот конечное значение npow нужно изменть и все заработает.

[1:39] 
стоп, все работает, кроме степени = 0. Тогда infinite loop

jougene [1:39 PM] 
нет

[1:39] 
2 в 1 = 2

[1:40] 
дальше 2 во 2 он считает 8

[1:40] 
потом он 2 в 5 и 2 в 6 считает 32

yel1owstone [1:40 PM] 
Я к тому что если в cond поставить (= npow 1).

jougene [1:40 PM] 
так пробовал

[1:42] 
тогда 2 в 1 будет один уже ))

[1:42] 
а дальше тоже самое

atosdo [1:49 PM] 
@jougene: 
ну вот давайте посчитаем для 2, 2
первый вызов даст (iter (/ 2 2) (* 1 (square 2)))

а второй пойдет по ветке else и еще раз умножит на 2 - потому и 8(edited)

yel1owstone [1:49 PM] 
я понял.

[1:49] 
ты забыл указать еще одни случай.

atosdo [1:50 PM] 
вот)

yel1owstone [1:50 PM] 
+ у тебя ошибка в базовом случае.

[1:50] 
Подытожу: Всего 4 кейса должно быть.

[1:50] 
2 из них базовые.  base case.

[1:51] 
2 остальных: 1 для четной степени, второй для нечетной. С этим у тебя все верно.

[1:52] 
Если степень будет равна нулю ответ будет всегда один) и тот же. Так?

jougene [1:52 PM] 
и один должен быть для npow = 2

atosdo [1:52 PM] 
когда делим на 2 четное - в итоге все равно будет 1 и для этого случая нет возврата

[1:52] 
потому  и оно еще раз идет на ветку, для нечетного и умножает еще раз - потому и перебор на одну степень

jougene [1:55 PM] 
два базовых случая, то бишь для n=1

[1:55] 
и для n = 0

yel1owstone [1:55 PM] 
да

jougene [1:55 PM] 
если n=1 то мы чтот возвращаем

yel1owstone [1:55 PM] 
основание.

jougene [1:56 PM] 
а если n=0, то результат?

yel1owstone [1:56 PM] 
всегда 1?

atosdo [1:57 PM] 
n = 0 => 1

[1:57] 
Это в рекурсии, а итерации думайте)

jougene [2:00 PM] 
смотрите, у нас 4 случая

[2:00] 
2 я сделал правильно -

[2:00] 
2 остальных - это для степени = 0

[2:00] 
и = 11

[2:00] 
1

[2:01] 
если у нас степень равна 0, то мы должны вернуть результат

[2:01] 
или нет

[2:02] 
я запутался

[2:02] 
как всегда с итерацией

yel1owstone [2:03 PM] 
я тоже запутался. )

[2:03] 
Я ее вроде решал. Задача с инвариантом.

jougene [2:03 PM] 
да

[2:04] 
что такое инвариант не объясняется

[2:04] 
ну типа чтот неизменяемое наверн

ignat [2:39 PM] 
это 1.16?

yel1owstone [2:44 PM] 
да.

[2:45] 
Меня раздражает, что я это решал, А теперь не могу. :simple_smile: Можно прикинуть что половину решенных упражнений я спустя время не решу.

ignat [2:46 PM] 
инвариант, как я понял из книжки, это значение, которое не меняется при каждом вызове функции

[2:46] 
в данном случае это a*b^n

[2:48] 
в примере югена у функции iter есть аргументы n и a, но нет b(edited)

kirill.mokevnin [2:48 PM] 
https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D1%8F#.D0.94.D0.BE.D0.BA.D0.B0.D0.B7.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D1.81.D1.82.D0.B2.D0.BE_.D0.BA.D0.BE.D1.80.D1.80.D0.B5.D0.BA.D1.82.D0.BD.D0.BE.D1.81.D1.82.D0.B8_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC

[2:48] 
это очень важная штука, по тому как доказывать корректность рекурсии и циклов

[2:48] 
для рекурсии не нужен инвариант

[2:49] 
если научиться действовать по этому пути, то вам проще станет писать рекурсивный код(edited)

i.rastypain [2:57 PM] 
про герб не знал)

yel1owstone [3:04 PM] 
@kirill.mokevnin: в статье ведь только про доказательство  корректности рекурсивной процедуры.

kirill.mokevnin [3:06 PM] 
именно так на нее можно смотреть

[3:06] 
и убеждаться что она работает

[3:06] 
часто проблема в том что те кто пытаются отлаживать и писать рекурсивные функции, смотрят на функцию как на монолит

[3:06] 
и пытаются держать в голове все детали

[3:07] 
поэтому все кажется очень сложным

[3:07] 
а, на самом деле, каждую ветку можно рассмотреть отдельно и убедиться в ее корректности независимо(edited)

[3:07] 
разделяй и властвуй в действии

yel1owstone [3:09 PM] 
С рекурсией понятно. Сейчас с инвариантом разбираемся)

[3:10] 
Я имею ввиду, что в задаче требуется итеративное решение.

[3:11] 
Наверняка есть подобный подход к итеративности, который упрощает.

kirill.mokevnin [3:11 PM] 
э не

[3:11] 
не важно что процесс итеративный

[3:11] 
важно что нет изменения состояния

[3:11] 
у вас просто на каждой ветке есть вход и есть выход

[3:12] 
вы просто доказываете его верность для одного случая, а значит оно верно для всех

yel1owstone [3:18 PM] 
я решил эту задачу только что )

yel1owstone [3:23 PM] 
@kirill.mokevnin: вы имеете ввиду, что неважно рекурсивная процедура или рекурсивный процесс? подход доказательства один?

kirill.mokevnin [3:23 PM] 
да

[3:23] 
в сети можно загуглить про инвариант в циклах, там прямо показывается как он нарушаться может

[3:23] 
из за присваивания

[3:24] 
поэтому на циклах инвариант проверяется на всех итерациях

[3:24] 
это означает что вы в принципе доказать его корректность без выполнения не можете

yel1owstone [3:25 PM] 
@jougene: в условии задачи написано указание: используйте наблюдение, что (b^(n/2)) = (b * b)^(n/2)

jougene [3:25 PM] 
ок, я использовал это чтоб вычислять значение при четной степени

yel1owstone [3:26 PM] 
Так цикл в сикпе это рекурсивная процедура.

kirill.mokevnin [3:26 PM] 
это не цикл)

[3:26] 
в цикле идет оперирование присваиванием

[3:26] 
в этом вся соль

[3:27] 
в фп у вас нет присваиваний

[3:27] 
изменения состояния

[3:27] 
это сильно все меняет

[3:27] 
у вас минус одна ось это время

[3:27] 
порядок применения не важен

jougene [3:27 PM] 
мы присваивание делаем с помощью вызова рекурсивной процедуры с измененными параметрами

kirill.mokevnin [3:27 PM] 
вспомните циклические алгоритмы сложные, все время идет путаница между тем что за чем присвоить

jougene [3:27 PM] 
ну типа мы их так меняем

yel1owstone [3:27 PM] 
@kirill.mokevnin: если нет присваивания, то это не цикл?

kirill.mokevnin [3:27 PM] 
не ребят, давайте не путать, это называется binding

[3:27] 
связывание

[3:27] 
вы даете имя значению или выражению

jougene [3:27 PM] 
Кирилл, в рекурсии?

kirill.mokevnin [3:27 PM] 
но оно не меняется

[3:28] 
не обязательно в рекурсии

[3:28] 
при декларативном (функционалном коде)

[3:28] 
a = 4

[3:28] 
в математике это тоже ок

[3:28] 
но вы не можете потом сказать что a = 5

[3:28] 
потому что она уже равна 4

[3:28] 
по сути это просто имя для значения

[3:28] 
соответственно если к вам в функцию пришли a b и c, то они ими и останутся

[3:29] 
есть такое понятие, референциальная прозрачность

[3:29] 
которое как раз об этом

[3:29] 
вы в процессе вычисления легко можете имя заменить на его значение

[3:29] 
и это будет корректно

[3:29] 
когда у вас есть явное изменение (переменные), то вы не можете так сделать

[3:29] 
все это имеет глубокие последствия

yel1owstone [3:30 PM] 
я запутался.

kirill.mokevnin [3:30 PM] 
чтобы все это лучше понять, надо почитать про лямбда-исчисление и машину тьюринга

[3:30] 
мы об этом тут каждый день говорим почти

[3:30] 
вы ж вроде тут давно?

jougene [3:30 PM] 
Вы уверены, что если я вот щас почитаю про лямбда исчисления и машину Тьюринга, то мне все станет понятней?

kirill.mokevnin [3:31 PM] 
не сразу, но это то на чем все базируется

[3:31] 
вы слышали про тьюринг полноту?

jougene [3:31 PM] 
нет

kirill.mokevnin [3:31 PM] 
что значит “язык полный по тьюрингу"

jougene [3:31 PM] 
я не знаю, но где об этом узнать?

kirill.mokevnin [3:31 PM] 
вот это важно

yel1owstone [3:31 PM] 
это значит, что имея. базовый набор можно выразить все что угодно.

jougene [3:31 PM] 
какой источник лучше использовать

kirill.mokevnin [3:31 PM] 
обычно об этом узнают на первом курсе соответствующих специальностей

i.rastypain [3:31 PM] 
где можно решить любую задачу

kirill.mokevnin [3:31 PM] 
но без образования можно идти на вики)

yel1owstone [3:33 PM] 
Имея комбинации "и" и "или" "1" и "0" можно запрограммировать все. Так?

kirill.mokevnin [3:34 PM] 
не знаю) но базисы могут быть разные это да

jougene [3:34 PM] 
ну это же основа компьютера

kirill.mokevnin [3:34 PM] 
вопрос в вычислимости

jougene [3:34 PM] 
с помощью и или мы делаем искл или

[3:34] 
потом сумматор

kirill.mokevnin [3:34 PM] 
дело в том что вычислимость это не обязательно связь с аппаратной частью

[3:34] 
вот он императивный мозг)

[3:35] 
вычислимость это вообще в целом возможность построить функцию вычисляющую алгоритм

i.rastypain [3:35 PM] 
так по большей части сами компы тут не причём. так?

kirill.mokevnin [3:35 PM] 
это все про математику

[3:35] 
и это формальные штуки, которые сопровождаются теориями теоремами леммами доказательствами и диссертациями

[3:36] 
мы в правильном чате это обсуждаем да)

[3:36] 
так вот тьюринг придумал свою машину

[3:36] 
лента

[3:36] 
вот имея те возможности которая имеет машина тьюринга можно запрогать все что вычислимо

[3:36] 
понято что это не совсем так, потому что физический мир имеет ограничения

[3:37] 
вы запрогаете, но вычисляться оно может миллионы лет

[3:37] 
в теории

[3:37] 
так вот машина тьюринга это всего лишь эталон, существует много других базисов

[3:37] 
в том числе тех которые проще

[3:38] 
если доказывается что ваш базис (ваша машина например) эквивалентна машине тьюрингу по мощности

[3:38] 
значит она тьюринг полная

[3:38] 
значит можно делать все тоже самое что и на тьюринг машине

[3:38] 
так вот императивные языки равномощны

[3:38] 
для примера, регулярки не равномощны

[3:38] 
они не являются тьюринг полными

i.rastypain [3:39 PM] 
а другой модели нет, кроме как представление Тьюринга?

kirill.mokevnin [3:39 PM] 
невозможно программировать только с помощью регулярок

[3:39] 
я к этому и веду

[3:39] 
тьюринг творил в тридцатые года

[3:39] 
до появления компов

[3:39] 
и у него была куча коллег крутых

[3:39] 
один из них фон нейман, отец основатель компов (все современные компы имеют фон неймовскую архитектуру)(edited)

[3:39] 
и был еще один гениальный тип

[3:40] 
алонзо черч

[3:40] 
он придумал лямбда исчисление

[3:40] 
lambda calculus

[3:40] 
формальная система, разработанная американским математиком Алонзо Чёрчем, для формализации и анализа понятия вычислимости.

[3:41] 
он его придумал чтобы решить какую то задачу, вроде теорема геделя о неполноте

[3:41] 
но могу наврать

[3:41] 
в общем в итоге знаете что оказалось?

yel1owstone [3:41 PM] 
пока нет.

kirill.mokevnin [3:42 PM] 
то что лямбда исчисление оказалось полным по тьюрингу

[3:42] 
большинство современных языков (императивные) опираются на архитектуру компьютера и работают активно манипулируя изменением состояния

[3:43] 
переменные это сразу приговор

[3:43] 
императивный язык

[3:43] 
отсюда много следствий

[3:43] 
например такие языки обладают кучей проблем

[3:43] 
которых нет в языках основанных на лямбда исчислении

[3:43] 
первым из которых был лисп - это прямая копия лямбда исчисления в программирование

[3:44] 
поэтому лисп бесммертен

yel1owstone [3:44 PM] 
@kirill.mokevnin: можно я перебью? Я все про циклы.

kirill.mokevnin [3:44 PM] 
это не просто язык

[3:44] 
так вот циклы это про императивные языки

[3:44] 
и про присваивание

[3:44] 
в лямбда исчислении нет циклов, там только рекурсия и отсутствие изменения состояния

[3:44] 
то чем вы сейчас и занимаетесь

[3:44] 
вы осознали что сейчас учите лямбда исчисление?)

yel1owstone [3:45 PM] 
я догадывался об этом :simple_smile: когда в сикпе была глава "lambda-исчисление"

[3:45] 
Вопрос.

[3:46] 
Я не понимаю о какой неизменяемом состояние вы говорите?

[3:46] 
Например.

kirill.mokevnin [3:46 PM] 
они просто хитрые, специально не говорят страшны слов

[3:46] 
давайте

yel1owstone [3:46 PM] 
Есть функция в лиспе.

atosdo [3:46 PM] 
но прикол, что все равно в итоге все будет императивно в машинных кодах, но это так))) к слову.

yel1owstone [3:46 PM] 
Где параметры итеративно меняются.

kirill.mokevnin [3:47 PM] 
они не меняются

jougene [3:47 PM] 
я пока не осознал что учу лямбда исчисление

kirill.mokevnin [3:47 PM] 
у вас новая функция

yel1owstone [3:47 PM] 
:simple_smile:

kirill.mokevnin [3:47 PM] 
со своим окружением

[3:47] 
каждый раз новая функция

atosdo [3:47 PM] 
с чистого листа) как бы

kirill.mokevnin [3:47 PM] 
в этом и вся фишка, создается ощущение что мы что то меняем

yel1owstone [3:47 PM] 
Ок. Значит у цикла больше одного смысла_)

jougene [3:47 PM] 
а по факту просто новая функция

kirill.mokevnin [3:48 PM] 
на самом деле этого не происходит, у вас идет цепочка вычислений которая берет предыдущее значение и кидает в следующее

yel1owstone [3:48 PM] 
Цикл - то, что повторяется. Если хочешь чтобы он не был бесконечным, добавить условие выхода.

kirill.mokevnin [3:48 PM] 
в цикле ходят по кругу, a = temp, a = b, b = temp

[3:48] 
дело не в повторяемости, так)

[3:48] 
давайте разделять

[3:48] 
понятие процесса

[3:49] 
и императивность/декларативность

[3:49] 
у вас есть процесс итеративный и рекусивный, а еще бывает древовидный

[3:49] 
это отдельно

yel1owstone [3:49 PM] 
древовидный разве не часть рекурсии?

kirill.mokevnin [3:49 PM] 
можно и так сказать

yel1owstone [3:50 PM] 
если есть доп. условии в функции,, рождается дерево.

kirill.mokevnin [3:50 PM] 
главное то что цикл это а) всегда итеративный процесс б) всегда императивен, потому что основан на возможности менять состояние, то есть на переменных

[3:51] 
поэтому в функциональных языках нет циклов как класса

[3:51] 
обычно по ним сразу видно какой это язык

ignat [3:52 PM] 
Возвращаясь к первоначальному упражнению, у меня тогда возникает вопрос: зачем тогда автор говорит, что нужно менять состояние?

[3:52] 
keep, along with the exponent n and the base b, an additional state variable a, and define the state transformation in such a way that the product a bn is unchanged from state to state

yel1owstone [3:52 PM] 
unchanged же?

v.manenkov [3:52 PM] 
Я недавно пытался разобраться с понятием полноты по Тьюрингу. На практике это означает всего лишь то, что вы сможете записать каждую вычислимую на нем функцию. Это прямая отсылка к той статье в Википедии, которую давал Кирилл, потому что доказательство ровно то, что там написано. Рекурсия. Кроме того, можно взять любой Тьюринг полный язык программирования и показать, что любая элементарная конструкция на нем будет записываться и на вашем языке. Это будет тоже означать Тьюринг полноту яызка.

Можно и под другому доказывать. Это уже про лямбды. Там уже не рекурсией оперируют, а какими-то понятиями из теории лямбда-исчисления.  Честно говоря, из всего этого связи с отрицательными сторонами присваивания я не увидел.

kirill.mokevnin [3:53 PM] 
@v.manenkov: о, а ты не знаешь разве про это?

[3:53] 
видимо в сикпе не дочитал еще

[3:54] 
там прямо отдельно большая глава про недостатки присваивания

[3:54] 
в целом императивность привносит новое измерение

[3:54] 
которого раньше не было

[3:54] 
это понятие времени

v.manenkov [3:54 PM] 
Я читал про это. Читаю сейчас медленно и внимательно :simple_smile:

kirill.mokevnin [3:54 PM] 
`a` имеет лайфтайм(edited)

v.manenkov [3:54 PM] 
Про время тоже читал

yel1owstone [3:55 PM] 
@jougene: ты разобрался?

kirill.mokevnin [3:55 PM] 
да, там так же написано что это очень сильно влияет на внутреннее устройство

[3:55] 
потому что подстановочная модель перестает работать и надо использовать модель с окружениями для вычислений

jougene [3:55 PM] 
@yel1owstone: не так быстро, вы говорите о вещах, которые освещаются в последующих главах

yel1owstone [3:56 PM] 
Я про задачу

kirill.mokevnin [3:56 PM] 
ну и очевидно что компилятор/интерпретатор становится сложнее на порядок

jougene [3:56 PM] 
но я пока на первой главе, на упражнении с возведением в степень

kirill.mokevnin [3:56 PM] 
а внешняя история это про порядок присваивания например

v.manenkov [3:56 PM] 
А я на самом деле подумал, что подстановочная модель никуда не годится

kirill.mokevnin [3:56 PM] 
еще куда годится, это модель сто процентов отражающая суть

jougene [3:56 PM] 
и когда я пытался решить эту задачу, я написал 4 функции - это простое рекурсивное возведение

[3:56] 
потом с помощью итерации

kirill.mokevnin [3:57 PM] 
именно так можно нулевым людям объяснять что такое программа и как она работает

jougene [3:57 PM] 
потом с помощью рекурсии и делении степени на 2

v.manenkov [3:57 PM] 
А как же замыкания?

kirill.mokevnin [3:57 PM] 
давайте сделаем бета редукцию

[3:57] 
а что с ними?

[3:57] 
замыкание идет по значению(edited)

jougene [3:57 PM] 
и потом попытался посмотреть в чем закономерность и написать 1.16 упражнение

yel1owstone [3:57 PM] 
@jougene: ну так написал?)

jougene [3:57 PM] 
по логике я описал все схематично, попытался решить в ракете

v.manenkov [3:57 PM] 
А, мы же не можем переопределять внутри. Тогда да, круто

jougene [3:58 PM] 
и столкнулся с вот такой проблемой, которую выше излага

[3:58] 
л

kirill.mokevnin [3:58 PM] 
@jougene: я вам рекомендую взять кложу и lighttable

[3:58] 
она обладает офигенными штуками для отладки лисп кода

jougene [3:58 PM] 
@kirill.mokevnin: то есть щас слезть с лиспа и сикпа и взять closure?

kirill.mokevnin [3:58 PM] 
этот редактор создан для лиспов

jougene [3:58 PM] 
для того чтоб что-то понять?

kirill.mokevnin [3:59 PM] 
дык лиспы между собой не отличаются на базовом уровне

[3:59] 
это ведь все лямбда исчисление

[3:59] 
структурки данных которыми вы описываете процесс вычисления

[3:59] 
http://lighttable.com/
Light Table is the next generation code editor. Light Table Connects you to your creation with instant feedback and showing data values flow through your code.

[3:59] 
@v.manenkov: так вот кроме порядка вычисления не забывай про огромную тему, это паралелльность

[4:00] 
императивщина делает все чтобы это было невозможно

[4:00] 
@jougene: с сикпа зачем слезать?

[4:01] 
clojure это самый современный и активно используемый в продакшене лисп

jougene [4:01 PM] 
вы

kirill.mokevnin [4:01 PM] 
делайте все задания в сикпе на нем просто и все

jougene [4:01 PM] 
имеете ввиду взять этот редактор, чтоб с помощью отладки посмотреть как все выполняется?

kirill.mokevnin [4:01 PM] 
да вам проще разобраться будет

jougene [4:01 PM] 
спасибо :smiley: я попробую

kirill.mokevnin [4:01 PM] 
просто я не уверен что он с ракетом дружит хорошо

[4:01] 
но знаю что хорошо дружит с кложей

[4:02] 
 ```(defn factorial [n]
  (reduce * (range 1 (inc n))))
```

[4:02] 
вот код на кложе, знакомо ведь?)

i.rastypain [4:02 PM] 
ну, кое-где буковок нет) а так всё одинаково

kirill.mokevnin [4:02 PM] 
да у них чуть другие соглашения, но принципы разработки на лиспах одинаковые

i.rastypain [4:03 PM] 
я вот использую пока что scheme диалект(edited)

yel1owstone [4:04 PM] 
@kirill.mokevnin: я все про циклы)

kirill.mokevnin [4:04 PM] 
да я уже все рассказал про них

yel1owstone [4:05 PM] 
ок.

kirill.mokevnin [4:05 PM] 
не ну вы пишите если не понятно), просто я к тому что выше есть все ответы

[4:05] 
другой вопрос что их еще надо увидеть

arbatskiy [4:06 PM] 
спасибо за Lighttable, а я установил Eclipse для clojure, щас удалю его нафиг

i.rastypain [4:06 PM] 
кстати, по поводу переменных. на первых упражнениях сразу же мозг выдавал решения с их использованием.

kirill.mokevnin [4:07 PM] 
так вас всю жизнь пихали императивным программированием

i.rastypain [4:07 PM] 
а позже увидел особенность, что и без них всё прекрасно можно решить. надобность отпала

v.manenkov [4:10 PM] 
Циклы и условия -- это высокоуровневые штуки. Первым делом нужно научиться заменять их на рекурсию. А вторым делом понять, что и рекурсия не нужна. Можно абстрагироваться до map, filter, reduce. Но это надо жестко способ мышления менять.

igrishaev [4:14 PM] 
интересно вы говорите. map, filter, reduce построены на хвостовой рекурсии(edited)

v.manenkov [4:14 PM] 
за вызовами этих функций её и скрываем

[4:15] 
только в этом смысле

igrishaev [4:15 PM] 
а компилятор разворачивает хвостовую рекурсию в цикл

kirill.mokevnin [4:15 PM] 
то как они построены зависит сильно от языка, в php внутри нет никакой хвостовой рекурсии

dstarcev [4:15 PM] 
но только не питона))

yel1owstone [4:16 PM] 
Есть у нас цикл for в pythonе. счетчик меняется, и на каждый счет меняется какая-то переменная. И есть функция в лиспе, где тоже есть счетчик, процедура итеративная, и тоже меняется какое-то икс. Я так понял, вы говорите что 1ый случай это цикл. А второй случай, тогда что? Я также понимаю, что в случае лисповской функции, функция рождается и умирает, передовая новые параметры новой функции. Говоря про изменяемость вы имеете ввиду, что в 1ом случае (python)  у нас есть одна функция и одна область значений и все изменения происходят в этой области. Говоря про неизменяемость вы имеете ввиду, что во 2ом случае (ЛИСП) нет одного scope рождают новые, но с новыми параметрами (то есть отдельно каждая функция со своим scope не меняется, а передает значения в новую функцию, пока не вычислит). Я правильно понял? То есть, если действия происходят в одном scope, то нельзя применять критерии доказательства итеративного процесса рекурсивной процедуры из https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D1%8F#.D0.94.D0.BE.D0.BA.D0.B0.D0.B7.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D1.81.D1.82.D0.B2.D0.BE_.D0.BA.D0.BE.D1.80.D1.80.D0.B5.D0.BA.D1.82.D0.BD.D0.BE.D1.81.D1.82.D0.B8_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC

kirill.mokevnin [4:16 PM] 
а в лисп машинах и цикла не было :wink:

yel1owstone [4:19 PM] 
как говорится: у меня было мало времени, поэтому написал сложно, долго и длинно.

kirill.mokevnin [4:20 PM] 
второй случай это так же как и первый итеративный процесс

[4:21] 
при этом там ничего не меняется, под изменением в программировании понимается наличие переменных

yel1owstone [4:21 PM] 
кто нибудь проверял racket дружит с lighttable?

kirill.mokevnin [4:21 PM] 
и то что в рамках одного скоупа (функции например) у вас `a` сначала равна 5, а потом та же `a` стала равна 10

igrishaev [4:22 PM] 
по-моему у ракета хорошая иде

[4:22] 
они с ней вообще неделимы.

kirill.mokevnin [4:22 PM] 
посмотри возможности lighttable, например watches(edited)

[4:22] 
там на главной есть

yel1owstone [4:23 PM] 
"и то что в рамках одного скоупа (функции например) у вас `a` сначала равна 5, а потом та же `a` стала равна 10" а в лиспе такое не возможно. Я понял.

kirill.mokevnin [4:23 PM] 
кто вам сказал что невозможно?

delaguardo [4:24 PM] 
joined #computer_science

yel1owstone [4:24 PM] 
о боги

kirill.mokevnin [4:24 PM] 
на самом деле возможно, потому что лисп не функциональный язык

[4:24] 
просто в сикпе до третьей главы с ним идет работа только в фп стиле

[4:24] 
и он не используется

jougene [4:24 PM] 
мы же можем define x 5 сделать

kirill.mokevnin [4:25 PM] 
а вы посмотрите оглавление сикпа

[4:25] 
третью главу

[4:25] 
https://docs.racket-lang.org/reference/set_.html

atosdo [4:27 PM] 
What languages does Light Table support?

Light Table's general editor capabilities will work with most languages out there, but it has deeper language integrations (things like inline eval) for Clojure, ClojureScript, Javascript, Python, HTML, and CSS. More languages can be added via plugins in the future.

kirill.mokevnin [4:27 PM] 
а к задаче выше, ну если вы уже используете рекурсию, то смешивать ее с изменяемым состоянием это вообще адская смесь), поэтому цикл и переменные vs рекурсия без изменения

yel1owstone [4:28 PM] 
там же итерация

kirill.mokevnin [4:29 PM] 
при рекурсии у вас процесс может быть разным

[4:29] 
функция от этого не перестает быть рекурсивной

yel1owstone [4:30 PM] 
я разобрался. спасибо.

kirill.mokevnin [4:31 PM] 
еее!

yel1owstone [4:31 PM] 
я очень тугой. или шансы есть?

kirill.mokevnin [4:31 PM] 
не, наоборот

[4:31] 
вы не видели когда мы тут по 4 часа не могли объяснить человеку что такое функция

[4:31] 
вот там было сложно да

jougene [4:32 PM] 
я тоже очень тугой изза императивщины

[4:32] 
которая была в универе

kirill.mokevnin [4:32 PM] 
просто когда вы погружаетесь в эту тему, на вас давят стереотипы и привычки

[4:32] 
слишком сильно

[4:32] 
мы уже многих тут вылечили :smile:

atosdo [4:32 PM] 
все мы тугие тут собрались, походу :simple_smile:

kirill.mokevnin [4:32 PM] 
я ведь тоже когда то считал себя богом ооп

[4:32] 
про паттерны могу про ddd часами рассказывать

[4:32] 
а потом попал в правильную компанию и пошла жизнь по наклонной

[4:32] 
всего три года назад

v.manenkov [4:35 PM] 
А я паттерны как не смотрел, так и не понял нафига такие сложности. Там много просто тех, которые нужны чтобы скрыть плохонаписанный код. Почему бы просто не переписать?

[4:35] 
Хотя понятно, что сроки и всё в таком духе

kirill.mokevnin [4:35 PM] 
есть такая прикольная аналогия

[4:35] 
ты знаешь что количество маршруток в городе определяет количество проблем с общественным транспортом?

[4:35] 
чем больше тем хуже

[4:36] 
так же с паттернами, но это полушутка полуправда

[4:36] 
потому что там действительно много штук созданных из за ограничений, а много крутых вещей, но это не про ооп, а в целом про жизнь(edited)

yel1owstone [4:36 PM] 
Я наверное понимаю этого человека. На самом деле вопрос еще в другом. Стараясь дать определение всему приходишь в тупик. На самом деле недостаточно слов в человеческом языке, чтобы выразить все смыслы. Человеческий язык наверное не полон по тьюрингу)А есть такие люди, которые хотят понять каждую букву. Ремонт нельзя закончить, его можно только прекратить. Мне кажется с объяснениями так же. Короче нужно уметь абстрагироваться. Как считаете?

[4:36] 
Я про того человека с функциями.

[4:36] 
Все я умолкаю)

kirill.mokevnin [4:37 PM] 
я думаю тут еще будут подобные беседы)

jougene [4:37 PM] 
язык с точки зрения лингвистики рекурсивен

kirill.mokevnin [4:37 PM] 
любая программа тоже

[4:37] 
на любом языке)

v.manenkov [4:37 PM] 
а он рассматривал его как набор символов просто. Потому и не понимал

jougene [4:37 PM] 
а интерпретатор лиспа на лиспе написан, да?

kirill.mokevnin [4:38 PM] 
компилятор go написан на go

[4:38] 
компилятор си на си

[4:38] 
обычная история

[4:38] 
лисп пишется на чем угодно очень быстро

igrishaev [4:38 PM] 
интерпретаторы лиспа на многих языках пишут.

[4:39] 
самая популярная реализация common lisp SBCL написана на C + сам же лисп

vgv [4:40 PM] 
Лисп пишется быстро там, где есть уже GC

[4:40] 
Попробуйте на том же C его “быстро написать"

v.manenkov [4:40 PM] 
Я пытаюсь. Сложно, да(edited)

kirill.mokevnin [4:40 PM] 
это отличное дополнение)

vgv [4:41 PM] 
Ну, как я уже говорил - я писал лисп на турбо-паскале

[4:41] 
Я до сих пор помню что было вообще не просто и самая сложная часть тогда для меня был сборщик мусора

[4:41] 
причем многих частей не было там вообще

[4:41] 
напрмер, TCO и макросов я не писал совсем

[4:41] 
не знал про них

[4:42] 
то есть это был даже не лисп, а такой очень кастрированный язык с синтаксисом лиспа

[4:42] 
как я сейчас понимаю(edited)

kirill.mokevnin [4:42 PM] 
кто не знает @vgv это удивительный человек, который вошел в программирование через лисп

vgv [4:42 PM] 
Не, лисп был вторым )

kirill.mokevnin [4:42 PM] 
мне кажется ты один такой на свете)

[4:42] 
аа

vgv [4:43 PM] 
У меня родители тогда меняли квартиру и я нашел подборку журналов типа НАука и Жизнь

[4:43] 
а там часто писали что-то такое, про программирование

[4:43] 
про Бейсик, Рефал, программируемые микрокалькуляторы и прочее

[4:43] 
и в одном выпуске было про лисп

[4:43] 
Ну и я прочитал и натурально вдохновился

[4:43] 
Буквально две страницы там было

[4:44] 
Синтаксис-то простой, на двух страницах много чего можно уместить

[4:44] 
Это я потом понял, когда уже в универе на лисп посмотрел что, видимо, в том журнале еще нескольких страниц не было )

[4:45] 
А тогда мне показалось что “вот две страницы, логично все написано, фраза на середине не обрывается - ну, видимо, это весь лисп"

[4:45] 
Я и засел его писать в школе, на TP 7.0

[4:45] 
так что первый был паскаль, все таки )

jougene [4:47 PM] 
было бы прикольно начать обучение с лиспа

[4:47] 
чтоб не было джавы головного мозга

[4:47] 
чтонаверное и встречается у тех кто щас себя обозначил тугим

[4:47] 
надо перенастроить мозг

v.manenkov [4:48 PM] 
Главное с джавы не начинать :smiley:

[4:48] 
Я не понимаю как можно сразу ооп с нуля

delaguardo [4:48 PM] 
почему нет?

jougene [4:48 PM] 
вот в том то и дело что я на хекслет с джавы и попал ))
4  

dstarcev [4:48 PM] 
парни, никода не поздно переформатироваться

delaguardo [4:48 PM] 
всем привет, кстати, я тут впервые(edited)

kirill.mokevnin [4:49 PM] 
@vgv слушай а у тебя много же чуваков которые всегда только на java писали и другого не видели вообще

[4:49] 
бывают из-за этого сложности?

vgv [4:49 PM] 
Нет, вот прямо таких как раз нет

kirill.mokevnin [4:49 PM] 
ну что человек мог бы решить задачу по другому если бы знал другой подход

vgv [4:49 PM] 
более того, у нас половина приходит вообще без знания Java

kirill.mokevnin [4:49 PM] 
ну студенты то понятно

vgv [4:49 PM] 
Не, не студенты

[4:49] 
опытные разработчики

kirill.mokevnin [4:50 PM] 
я просто с нуля кучу рубистов взростил и могу сказать что это офигеть как влияет

vgv [4:50 PM] 
C++, C#, Erlang, Ruby

kirill.mokevnin [4:50 PM] 
когда это единственный продакшен язык

vgv [4:50 PM] 
это что я сходу вспомнил

kirill.mokevnin [4:50 PM] 
прямо заставлять приходилось в другие языки отправлять

vgv [4:51 PM] 
Да, но я на это несколько по другому смотрю, наверное, не так как ты. Если ты в любом языке тупо засел и всё - ты не продвинешься никуда. Lisp/Java/Haskell/Basic.

[4:51] 
Надо всегда идти дальше
2  

[4:52] 
Причем, можно не в другие языки, а в этот же, но на другой уровень. Я могу сказать про Java как пример - можно попробовать погрузиться в алгоритмы работы виртуальной машины, JIT и GC, можно попробовать понять что такое модель памяти и почему она такая (привет, современные процессоры!) и прочее

kirill.mokevnin [4:52 PM] 
там дело не только в самом росте, а в ограниченности мышления чтоли

vmashanov [4:52 PM] 
joined #computer_science. Also, @vladbesson joined.

kirill.mokevnin [4:52 PM] 
люди не видят возможностей там где они есть

[4:52] 
причем это не только про “писать код"

vgv [4:52 PM] 
И это тоже уводит тебя от базовых знаний, но  не “вширь”, как другие языки(edited)

[4:52] 
А больше “вглубь"

[4:53] 
кому это нравится, кому другое

[4:55] 
Мне лично всегда было интересно вглубь, поэтому сейчас читаю книжку про современные процессоры

[4:55] 
Чтобы лучше писать на Java :simple_smile:

kiote [4:56 PM] 
joined #computer_science

vgv [4:58 PM] 
Вот эту книжку, если кому интересно - http://www.amazon.com/Computer-Architecture-Fifth-Edition-Quantitative/dp/012383872X
Computer Architecture, Fifth Edition: A Quantitative Approach (The Morgan Kaufmann Series in Computer Architecture and Design) [John L. Hennessy, David A. Patterson] on Amazon.com. *FREE* shipping on qualifying offers. The computing world today is in the middle of a revolution: mobile clients and cloud computing have emerged as the dominant paradigms driving programming and hardware innovation today. The Fifth Edition of Computer Architecture focuses on this dramatic shift
2  

deppkind [4:58 PM] 
joined #computer_science

sora [4:59 PM] 
А я всегда наивно думал, что на Java особо не оптимизируешь под процессор, виртуальная машина ведь...

vgv [4:59 PM] 
Это наивный подход. Если вы готовы читать - я готов кинуть материалы )

sora [5:00 PM] 
Спасибо, пока не дорос :simple_smile:

vgv [5:02 PM] 
Если кратко - ряд систем для HFT (high-frequency trading) написан на Java. Одна из таких - LMAX Disruptor

[5:03] 
У них очень интересные статьи (и не только у них) как они добиваются нано-секундных latency и вообще высокой пропускной способности

sashashakun [5:03 PM] 
Хм, до этого слышал что такие системы пишут только на плюсах

vgv [5:03 PM] 
Ну я знаю как минимум две на Java, а может есть и больше(edited)

[5:04] 
Причем, все они в качестве одной из главных причин почему на Java называют скорость разработки

[5:05] 
И, по сравнению с C++, думаю это оправдано

[5:05] 
Но это уже, видимо, random-канал начался )

sergeykulaga [5:05 PM] 
joined #computer_science

k1s [5:05 PM] 
не все же фп обсуждать

sashashakun [5:06 PM] 
Тут ещё было предложение про алгоритмы пообщаться

[5:06] 
Кажется от @v.manenkov

igrishaev [5:08 PM] 
к слову, джава медленней плюсов примерно в 1.7 раз, что очень мало. вбросы типа “жаба тормозит” уже неактуальны

k1s [5:09 PM] 
почему 1.7, а не 1.8?

dstarcev [5:11 PM] 
претензии к джаве обычно это претензии к GC

[5:12] 
если сравнивать скорость вычислений, я не думаю что разница будет неприемлемой

vgv [5:13 PM] 
Ну, тут очень тонкий момент

[5:13] 
потому что JIT

[5:13] 
который смотрит на конкретный процессор

[5:13] 
(в том числе)

[5:14] 
Например, очень простой пример

alexmold [5:14 PM] 
joined #computer_science

vgv [5:14 PM] 
в Java есть метод Integer.bitCount(value)

igrishaev [5:14 PM] 
с gc тоже уже научились работать

vgv [5:14 PM] 
метод и метод, ничего особенного

[5:15] 
Но в некоторых процессорах есть прямо инструкция, которая это делает

[5:15] 
И если JIT видит что прямо сейчас мы работаем на таком процессоре - заменяет все вызовы Integer.bitCount() на одну процессорную инструкцию

[5:15] 
А если процессор постарее - ну, считает как всегда

[5:16] 
Это просто пример, выхваченный из головы

[5:16] 
JIT умеет делать сотни всяких (на мой взгляд - очень интересных) штук

[5:16] 
Могу как-нибудь рассказать про это более подробно

[5:17] 
И что совсем хорошо - это не уровень языка, это уровень JVM, а значит JIT работает в любых программах - на Java, Scala, Clojure etc.(edited)

k1s [5:17 PM] 
расскажите как-нибудь
1  

amlagoda [6:30 PM] 
joined #computer_science. Also, @nemon joined, @eye joined, @j0 joined.

kirill.mokevnin [9:24 PM] 
смотрите что нашел, про языки архитектуру фон неймана, машину тьюринга https://www.youtube.com/watch?v=p7lwrOE7T3U
YouTube
Для школьников
022. Малый ШАД - Как правильно выбрать язык программирования - Иван Калинин
 
2  

atosdo [10:20 PM] 
и это для школьников лекция? жесть)

[10:20] 
я в школе про такое  не мог и подумать даже)

[10:22] 
Лектор куда-то спешит, нет четкости речи... :disappointed:

[10:25] 
10 минут максимум)) далее - ниасилил)))

kirill.mokevnin [10:27 PM] 
почему?

[10:31] 
по мне офигенное видео, я щас для себя открываю тоже новых штук

eye [10:45 PM] 
половину прослушал, на х1.5 скорости ) ну обзор языков добротный, современный. Правда в институте половину этого узнал, вторую с хабра и хекслета, в итоге процентов 15 по истории языков действительно нового для меня, а еще я про пролог не услышал ). Но для новеньких лекция очень даже. :simple_smile: Надо вторую половину оценить.

kirill.mokevnin [10:47 PM] 
про 80 круто

[10:47] 
я теперь знаю откуда это на самом деле

eye [10:49 PM] 
систематизация знаний вообще всегда круто :simple_smile: хорошо рассказали.

arbatskiy [10:52 PM] 
Спасибо, буду смотреть этот канальчик перед сном! Как раз читаю алгебру за 11 класс, школьникам все понятнее объясняют :smile:

kirill.mokevnin [10:53 PM] 
)

kirill.mokevnin [11:00 PM] 
так но вот про ооп он там конечно погнал вообще не туда

homax [11:52 PM] 
joined #computer_science. Also, @skavi_cos joined.


----- January 20th -----
arbatskiy [10:28 AM] 
вот еще вчера смотрел

[10:28] 
https://www.youtube.com/watch?v=NBuDJWf52KA
YouTube
Для школьников
016. Малый ШАД - Основы функционального программирования - Иван Бибилов
 

[10:28] 
в аудитории совсем мелкие детишки, просто респект им если они это все понимают

alex_r [10:40 AM] 
ну вопросы в конце задают вполне осмысленные

arbatskiy [10:40 AM] 
да мне показалось сначала что там вообще 5 класс, а в конце видно что старшеклассники

alex_r [10:41 AM] 
да, наверное 8-9 классы и старше

[10:41] 
но всё равно круто)

melekes [10:54 AM] 
left #computer_science

dstarcev [11:21 AM] 
Детишки лучше взрослых понимают

ssnpvl [11:55 AM] 
Как остановить выполнение цикла в методе с помощью другого метода?

[11:55] 
Objective-c

[11:57] 
Есть идея, сделать так, чтобы второй метод возвращал yes/no. Как тогда сделать, чтобы первый метод при смене значения на yes/no реагировал на это остановкой цикла?

alex_r [11:57 AM] 
дык проверка и break или что там в obj-c )

ssnpvl [11:58 AM] 
А все, я придумал, сейчас протестирую

dstarcev [12:20 PM] 
Только исключение, только хардкор. А они есть в objective c?

ssnpvl [12:24 PM] 
Здесь есть все

dima.valuev [12:44 PM] 
joined #computer_science. Also, @sabian left.

jougene [12:58 PM] 
какую литературу можно взять по Closure? Просто поставил lighttable + closure по рекомендации Кирилла, чтобы было удобнее отлаживать упражнения из СИКПа

k1s [1:00 PM] 
https://aphyr.com/tags/Clojure-from-the-ground-up

igrishaev [1:04 PM] 
clojure for true and brave

[1:04] 
сайт + книженция

[1:05] 
первая глава про настройку емакса, кстати

v_kulikov [1:37 PM] 
joined #computer_science

delaguardo [2:19 PM] 
можно взять для emacs конфиг spacemacs и пропустить главу про настройку

eye [2:26 PM] 
Только сначала прочитать главу про настройку, чтобы узнать куда класть конфиг. (парадокс?)

delaguardo [2:31 PM] 
не надо, тут все написано) https://github.com/syl20bnr/spacemacs/blob/master/README.md

GitHub
syl20bnr/spacemacs
spacemacs - A community-driven Emacs distribution - The best editor is neither Emacs nor Vim, it's Emacs *and* Vim!

[2:32] 
кроме шуток, spacemacs великолепно работает с clojure

igrishaev [2:42 PM] 
ибо сидр

delaguardo [2:55 PM] 
и clj-refactor

ssnpvl [5:13 PM] 
Когда метод заканчивает работать, переменная класса, которая в нем использовалась, сохраняет свое значение?

dstarcev [5:13 PM] 
поле класса

[5:14] 
сохраняет

ssnpvl [5:14 PM] 
Хм, странно

dstarcev [5:14 PM] 
почему же?

[5:14] 
может ты не в поле класса пишешь, а создал переменную с тем же именем

[5:14] 
такое бывает

[5:15] 
особенно если на php пишешь после java

[5:15] 
php только через $this

ssnpvl [5:16 PM] 
Нет, я на objc пишу. В классе объявил переменную, использую ее в одном методе, потом хочу ипользовать в другом. Она используется, но ее значение обнуляется

dstarcev [5:17 PM] 
может объект умирает

[5:17] 
и ты уже с другим работаешь

ssnpvl [5:18 PM] 
Объект все тот же. Метод отвечает за педальку газа (изменение сорости)

dstarcev [5:19 PM] 
скинь класс

ssnpvl [5:23 PM] 
http://pastebin.com/F2UDTghr
Pastebin
[Objective C] Car.h  ============  @interface Car : NSObject  {      int carSpeed;  }    enum  - Pastebin.com (19KB)

[5:26] 
У меня короткий тап по кнопке прибавляет скорость кратковременно, длинный тап прибавляет скорость, а когда юзер отжимает кнопку, скорость должна уменьшаться, но она почему-то сразу становится равной 0

dstarcev [5:26 PM] 
а что в логе

[5:27] 
у тебя pushBrake в ноль уводит скорость

[5:28] 
сразу

ssnpvl [5:28 PM] 
В итоге работает только метод pushThrottle, а pushBrake, который должен выполняться за ним, не работает, потому что цикл в нем не выполняется из-за того, что переменная carSpeed == 0 уже после выполнения pushThrottle

dstarcev [5:28 PM] 
может я каких-то особенностей не знаю, но я вижу просто цикл, который за несколько итераций уводит скорость в ноль

ssnpvl [5:28 PM] 
Я проверил NSLog-ом

[5:29] 
Ладно :simple_smile:

[5:29] 
Я как разберусь, напишу

[5:31] 
pushBrake должен показывать уменьшение скорости, а он не показывает, значит цикл в нем не работает, потому что переменная carSpeed не удовлетворяет его условиям

dstarcev [5:32 PM] 
при выходе из предыдущего метод логируй сокрость

[5:32] 
прямо так пиши "method X ends with speed " + speed

praytic [5:34 PM] 
а что будет, если юзер все еще будет жать кнопку, а цикл уже закончится? тогда метод выполнится и не будет никаких действий до того, как юзер отпустит кнопку? (это я так, офтоп)

dstarcev [5:35 PM] 
я честно вообще не понимаю какая тут связь с отрисовкой, код выглядит как-будто он выполняется сразу, а не "плавно"

praytic [5:36 PM] 
ага, набирает скорость за 10 проходов цикла - вот это ускорение(edited)

dstarcev [5:36 PM] 
может какя-то магия есть в objective c

praytic [5:36 PM] 
но я думаю задача в другом поставлено у него, хз

[5:36] 
> а что будет, если юзер все еще будет жать кнопку, а цикл уже закончится? тогда метод выполнится и не будет никаких действий до того, как юзер отпустит кнопку? (это я так, офтоп)

ssnpvl [5:41 PM] 
Да, цикл закончится и будет ждать, пока юзер отожмет кнопку. Так же как вы в машине, выжмете газ в пол и на максимальной скорости будете ехать. Когда убираете ногу с газа, скорость падает. Это реализовано, пока что не плавно, надо прикрутить NSTimer. Проблема в том, что сразу после того, как пользователь отжимает кнопку, скорость становится 0. На выводе это видно. И методу pushBrake уже нету с чем работать.

[5:41] 
Короче, эта переменная какая-то не глобальная

[5:41] 
carSpeed

dstarcev [5:41 PM] 
а как ты используешь объект car?

[5:41] 
она не должна быть глобальной

[5:41] 
это поле объекта

[5:42] 
ну

[5:42] 
все понятно

ssnpvl [5:43 PM] 
added a Plain Text snippet 
- (IBAction)throttleLongPress:(UILongPressGestureRecognizer *)sender {
    Car * audi = [[Car alloc] init];
    if ( sender.state == UIGestureRecognizerStateBegan ) {
        [audi pushThrottle];
    }
Add Comment Click to expand inline 9 lines
dstarcev [5:43 PM] 
ты в методе каждый раз создаешь занво машину(edited)

[5:43] 
Car * audi = [[Car alloc] init];

[5:43] 
метод вызывается при тапе и при антапе

[5:43] 
и каждый раз новая тачка

[5:44] 
тебе надо машину создать один раз и положить куда-то, возможно в поле класса

ssnpvl [5:44 PM] 
Так, кажется я понял

[5:46] 
Нет, машина создается один раз и у нее вызывается метод один раз

dstarcev [5:46 PM] 
throttleLongPress вызывается два раза

[5:47] 
один раз при начале тапа, один раз в конце

ssnpvl [6:24 PM] 
static int carSpeed; в Car.m вот и все дела :simple_smile:

dstarcev [6:26 PM] 
ну это как бы костыль

ssnpvl [6:26 PM] 
added an Objective-C snippet 
Car is moving.
Car speed: 25 km/h
Car speed: 50 km/h
Car speed: 75 km/h
Car speed: 100 km/h
Add Comment Click to expand inline 24 lines
ssnpvl [6:26 PM] 
Зато теперь вывод правильный

[6:29] 
Насколько это корявый костыль я пойму в будущем, а пока все работает надо сделать плавность набора/сброса скорости

ssnpvl [6:34 PM] 
Car * audi = [[Car alloc] init]; вот строка создания объекта, он один. Потом ему отправляется сообщение выполнить метод увеличить скорость, а потом уменьшить скорость

dstarcev [6:34 PM] 
ты его создаешь каждый раз при вызове метода

[6:35] 
 ```IBAction)throttleLongPress:(UILongPressGestureRecognizer *)sender {
    Car * audi = [[Car alloc] init];```

ssnpvl [6:35 PM] 
Этот метод один раз вызывается :simple_smile:

dstarcev [6:35 PM] 
нет, оно вызывается при каждом тапе и антапе

[6:35] 
добавь лог и увидишь

[6:36] 
это же обработчик события, как он может один раз вызываться? это не логично

ssnpvl [6:37 PM] 
Идея

[6:39] 
Я сейчас сделаю два метода, которые будут вызываться один раз и работать с одним объектом и посмотрю, как меняется переменная

dstarcev [6:39 PM] 
экспериментируй)

ssnpvl [6:45 PM] 
Ты прав, это все из-за обработчика

[6:45] 
Надо создать объект класса где-нибудь в другом месте

[6:46] 
Может отдельный метод сделать для этого?

dstarcev [6:46 PM] 
ну может там конструктор есть?

[6:47] 
или метод инициализации

[6:47] 
это уже специфика фреймворка(edited)

ssnpvl [6:47 PM] 
Метод класса сделать, чтобы объект был виден другим методам

kirill.mokevnin [6:48 PM] 
ребят, только то что вы обсуждаете это не computer science

[6:48] 
если можно, то в random или куда там можно с ios)

[6:48] 
может для мобильников сделать тему?

ssnpvl [6:48 PM] 
Сделайте! Пожалуйста

eye [7:08 PM] 
Сделаем пробный шаг к computer science, :innocent:  То, что @ssnpvl  использовал static поле в своем объекте - это напоминает Singleton шаблон, а суть проблемы использования его в этой задаче в том, что сколько бы объектов машинок он ни создал - у всех них поле carSpeed будет смотреть в одну и ту же точку памяти и иметь одну скорость, и влиять на нее все вместе. :simple_smile: Т.е. шаблон здесь не подходит, но может быть полезен для каких-то глобальных объектов, существующих в единственном экземпляре в системе, например, объект игрового мира, который один для всех объектов - игроков, нпс, мобов и пр.. Хотя не уверен, что на практике в геймдеве сейчас так делают, так что пример немного синтетический. Получилось свернуть к теме чата? :smiling_imp:
1  

kirill.mokevnin [7:09 PM] 
нет :wink:
2 2  

atosdo [7:29 PM] 
Давайте-ка я попробую,  у меня и пример имеется.
Вот задача 
​*Write a function that splits an array (first argument) into groups the length of size (second argument) and returns them as a multidimensional array.*​
Разбить массив на группы по size элементов и запихнуть эти группы, как под-масивы в массив.
Исходный массив = `console.log(chunk(["a", "b", "c", "d", "e"], 3));`
Как-то так  = `[ [ 'a', 'b', 'c' ], [ 'd', 'e' ] ]`

Я ее то решил на js - вот так:
```function chunk(arr, size) {
  function chunk_iter(index, result) {
    if (index >= arr.length) {
      return result;
    }
    
    result.push(arr.slice(index, index + size));
    return chunk_iter(index + size, result);
  }
  
  return chunk_iter(0, []);
}```

Но совесть терзает,  что я там использую push.
Может можно как-то иначе это сделать без явного изменения массива result???(edited)

dstarcev [7:38 PM] 
можешь копировать массив

shustrik [7:38 PM] 
joined #computer_science

dstarcev [7:39 PM] 
либо вот https://facebook.github.io/immutable-js/

[7:41] 
http://www.w3schools.com/jsref/jsref_concat_array.asp
Well organized and easy to understand Web bulding tutorials with lots of examples of how to use HTML, CSS, JavaScript, SQL, PHP, and XML.

[7:41] 
во

[7:41] 
Array.concat(acc, [newItem])

alexelizarov [9:33 PM] 
Здравствуйте! Прохожу сикп, книгу, наверное я тоже испорчен императивным мышлением, но я стараюсь на каждую разбирающуюся там тему придумать, а как это можно было бы сделать, например, на Java. И вот с ФВП уже придумывается тяжело. Там для объяснения ФВП разбирается пример с суммированием последовательностей.  На Java, пришлось бы объявить класс типа AbstractSequence, от него наследовать конкретные последовательности. Метод, суммирующий последовательности принимал бы в качестве параметра объект типа AbstractSequence ну и суммировал бы. Получается намного сложнее чем в сикпе. Это вообще нормальная идея, придумывать вот так аналоги на Java? Просто хочется не только понять что такое ФВП(типа, могут принимать функции и возвращать функции), хочется понять в чем смысл, какие преимущества. И самое главное, тут ведь наверное ценность не столько в ФВП, здесь как я понимаю какой-то базовый прием рассматривается даже не ФП, а программирования как такого. А какой? абстракция?

kirill.mokevnin [9:34 PM] 
это лямбда исчисление

[9:34] 
вы по сути математикой занимаетесь

praytic [9:34 PM] 
ну в java же есть stream api(edited)

alexelizarov [9:35 PM] 
Нет, вот интересно именно без этого stream api. Например, в java 7

kirill.mokevnin [9:35 PM] 
классы объекты и вот это все это приходяще уходящее это конкретные реализации конкретные языки конкретные года

[9:35] 
а фвп это появилось до компьютеров

[9:35] 
и это строгая формальная теория

[9:36] 
поэтому “в чем смысл” как бы правильно наоборот смысл искать)

dstarcev [9:38 PM] 
> Это вообще нормальная идея, придумывать вот так аналоги на Java?
я постоянно думаю как это выглядело бы в том или ином языке, мне нравится

sashashakun [9:39 PM] 
>На Java, пришлось бы объявить класс типа AbstractSequence, от него наследовать конкретные последовательности. Метод, суммирующий последовательности принимал бы в качестве параметра объект типа AbstractSequence ну и суммировал бы

Я джаву не знаю, но выглядит довольно монструозно)

alexelizarov [9:39 PM] 
Мне вот интересно, как вообще на Java 7 писали?) Причем крутые штуки ведь писали) Получается, есть что то, что позволяло эти концепции выразить и без ФВП? Как то сэмулировать? Или чем то заменить? Вот это интересует.

dstarcev [9:39 PM] 
там были анонимные классы вместо лямбды

alexelizarov [9:39 PM] 
Вот

dstarcev [9:39 PM] 
норм жили, а на андроиде и щас живут

alexelizarov [9:40 PM] 
то есть анонимыне классы помогают вот эту идею реализовать? В этом их главное предназначение? А не в том что бы какую то иерархию там строить? Так надо думать?

dstarcev [9:40 PM] 
в парадигме ООП  есть паттерн такой - стратегия. так это примерно то же самое что передать функцию в функцию

kirill.mokevnin [9:41 PM] 
не стратегия не совсем то

[9:41] 
это декоратор

[9:41] 
то что в фп естественно как функциональная композиция

[9:41] 
в ооп языках придумано спец понятие как декоратор

alexelizarov [9:42 PM] 
Как бы хочется видеть в чем базовая идея то. Вот наследование, например, для чего? Базовая идея наследования - повторное использование кода?

kirill.mokevnin [9:42 PM] 
нет

[9:42] 
это то как на самом деле его используют

alexelizarov [9:42 PM] 
И уже от этого плясать и думать как без ООП выразить повторное использование?

kirill.mokevnin [9:42 PM] 
базовая идея общее частное

alexelizarov [9:42 PM] 
а что?

kirill.mokevnin [9:42 PM] 
это не про общий код это даже не про программирование

sashashakun [9:42 PM] 
Уууу, чую лекцию

kirill.mokevnin [9:42 PM] 
нет), я щас убегу :smile:

[9:42] 
а то опять засосет

sashashakun [9:42 PM] 
а жаль)

kirill.mokevnin [9:43 PM] 
на самом деле хочется чтобы без меня такое проходило, вы все это знаете

[9:43] 
но вопросы правильные

[9:43] 
как раз такое должно появляться

[9:43] 
когда видишь немного другой стороны(edited)

[9:43] 
так что @alexelizarov вы на пути к просветлению)

alexelizarov [9:44 PM] 
@kirill.mokevnin: спасибо) а кажется что ухожу наоборот в темный лес)) но наверное луч света в этом лесу появится ближе к концу сикп)

[9:47] 
Но вот про наследование все-таки очень интересно. Общее-частное. А в ФП как то можно выразить эту идею? Или может там что то есть, что делает идею "общее-частное" вообще не нужной? Подскажите пожалуйста в каком направлении тут копать?

code4aman [9:47 PM] 
> к концу сикп
да вы крепкий орешек :smile:

dstarcev [9:48 PM] 
у меня уже сикп куплен, прям уже не терпится начать, что же там за супер челлендж такой
2  

kirill.mokevnin [9:49 PM] 
про наследование в сикпе будет в районе третьей главы

[9:49] 
а в целом все в ооп поняли уже давно что это зло

[9:49] 
поэтому везде кричат слово композиция

[9:49] 
понапридумывали паттерны

[9:49] 
и делают все чтобы избегать наследования
1  

alexelizarov [9:50 PM] 
Я как понимаю.. Ок, наследование, это приходящие, конкретная реализация. Но идея "общее-частное" это же базовая идея? как например, модификаторы доступа же не везде есть, но сокрытие данных вроде везде? То есть получается важная концепция - это именно сокрытие данных а не инкапсуляция? Или я не о том?

code4aman [9:51 PM] 
придумывать аналоги - по-моему нормально и иногда дает профит (хотя бы осознаете как просто/сложно что-то сделано в your_fav_lang), но в вашем примере - наследование это не та степь имхо, я из дотнета, там есть понятие делегата, так вот, после небольшого погружения в js я понял, как многие вещи сложно сделаны в дотнете

dstarcev [9:51 PM] 
у нас на проекте только композиция, наследования практически нет

sashashakun [9:51 PM] 
Инкапсуляция == сокрытие (реализации/данных)?

alexelizarov [9:52 PM] 
@sashashakun: реализации я подразумевал

v.manenkov [9:52 PM] 
инкапсуляция это сокрытие деталей реализации.

alexelizarov [9:53 PM] 
Только я подразумевал что как раз не равно

kirill.mokevnin [9:53 PM] 
помните я рассказывал про rand в языках программирования?

alexelizarov [9:53 PM] 
или все же равно?

kirill.mokevnin [9:53 PM] 
вот это и есть инкапсуляция

sashashakun [9:53 PM] 
Да, я помню

[9:53] 
Вроде сохраняли даже

alexelizarov [9:53 PM] 
Просто я прочитал что в Scheme нет инкапсуляции

[9:53] 
но сокрытие реализации то есть

sashashakun [9:54 PM] 
Что-то про то что ты не то что не даешь доступ к реализации, а вообще понятия не имеешь что там происходит и как(edited)

kirill.mokevnin [9:54 PM] 
дело в том что при правильном подходе любая составная структура это конструктор и селекторы(edited)

[9:55] 
то что многие считают инкапсуляцией и манной небесной

[9:55] 
в фп языках вы не можете просто к полям структуры обращаться напрямую

[9:55] 
всегда есть селектор

[9:55] 
хаскель, например, за вас умеет их генерировать

[9:56] 
поэтому инкапсуляция это сокрытие деталей реализации, например у вас внутри какое нибудь кеширование может быть

[9:56] 
или как в случае с rand вам надо предыдущее состояние знать, но остальным оно не сдалось

sashashakun [9:56 PM] 
ой затянет сейчас)(edited)

kirill.mokevnin [9:57 PM] 
:smile:

i.rastypain [9:57 PM] 
да уже)

kirill.mokevnin [9:57 PM] 
короче исходить надо не из мифических “наследование полиморфизм и тому подобное"

alexelizarov [9:58 PM] 
а из абстракция, сокрытие реализации и т.д?

kirill.mokevnin [9:58 PM] 
не

[9:58] 
идеальная программа это 1) декларативная программа

[9:59] 
желательно одна кнопка “сделать хорошо"

[9:59] 
если так не получится то хотя бы так “сформируй отчеты и отправь в налоговую"

[9:59] 
“доведи спутник до луны"

i.rastypain [9:59 PM] 
то есть решать минимум задач за один раз?

kirill.mokevnin [9:59 PM] 
все явно или неявно к этому стремятся

[9:59] 
высокие уровни

[9:59] 
построение абстракций

[10:00] 
2) программа должна сама себя доказывать

[10:00] 
https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B2%D0%B5%D1%80%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F вы когда нибудь над этим задумывались?

[10:01] 
кто знает для чего системы типов придуманы?

v.manenkov [10:01 PM] 
Для большинства программ строгая верификация не требуется

[10:01] 
Чтобы избавить от ряда ошибок на этапе компиляции
1  

kirill.mokevnin [10:02 PM] 
идеально избавиться ото всех ошибок

[10:02] 
вот люди спорят о всяких наследованиях, а на самом деле есть гораздо более серьезные и глубокие проблемы

[10:02] 
например null

[10:02] 
это хак над системами типов

[10:02] 
компиляторы вам не помогут с нулами

[10:03] 
и null pointer exception это стандартный кейс

apokall [10:03 PM] 
joined #computer_science

kirill.mokevnin [10:03 PM] 
Система типов — совокупность правил в языках программирования, назначающих свойства, именуемые типами, различным конструкциям, составляющим программу — таким как переменные, выражения[en], функции или модули. Основная роль системы типов заключается в уменьшении числа багов в программах[1] посредством определения интерфейсов между различными частями программы и последующей проверки согласованности взаимодействия этих частей.

[10:04] 
вы знаете что можно сделать так чтобы не было никогда null pointer ?

[10:04] 
и программа будет всегда корректно работать там где она раньше могла упасть

sashashakun [10:04 PM] 
Вот с этого момента пожалуйста поподробнее)

kirill.mokevnin [10:05 PM] 
кстати для этого паттерн тоже есть, nullobject

[10:05] 
null равен любому типу

[10:06] 
я честно скажу что тут уже зыбкая для меня область, потому что требует хорошего знания теории типов, я знаю ее весьма поверхностно

[10:07] 
но что я могу сказать

[10:07] 
бездоказательно)

[10:07] 
null приводит к куче специфических ошибок вы все о них знаете

[10:07] 
так вот как быть

[10:07] 
ответ простой, типы бывают разными)

[10:09] 
блин не могу с ходу правильные слова нагуглить, подзабылось уже

[10:10] 
в общем представьте что есть некий обобщенный тип MayBe a(edited)

[10:10] 
и он может быть MayBe [Char]

sashashakun [10:11 PM] 
Давайте что ли плюсанем кто здесь и слушает
14  

kirill.mokevnin [10:11 PM] 
при его обработке вы всегда два кейса описываете, что делать если внутри было что то(edited)

[10:11] 
и если внутри ничего не было

[10:12] 
поэтому обработка у вас никогда не упадет

[10:12] 
и дойдет до самого конца

[10:12] 
тут щас должна была появиться целая куча вопросов, но я пока только  на хаскеле это могу объяснить а не комплексно

[10:12] 
для примера посмотрите куда щас все идут

[10:12] 
в java добавили Option

[10:12] 
это и есть Maybe

[10:13] 
то есть optional

[10:14] 
я это все к чему собственно, все самое главное крутится вокруг типов

[10:14] 
знаете классический пример того как деревья в хаскеле описываются?

v.manenkov [10:15 PM] 
Нет

kirill.mokevnin [10:15 PM] 
смотрите

[10:15] 
data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show)

[10:15] 
это настоящий тип, такой же как встроенные

[10:16] 
у вас дерево может быть либо Empty (лист) либо Нода которая внутри себя содержит две подветки

[10:16] 
крутость в том что это определение описывает сразу все инварианты

[10:16] 
вы не сможете их нарушить

[10:16] 
вы не сможете туда добаить не то, не в том порядке, не в том количестве

[10:16] 
определение рекурсивно

[10:16] 
попробуйте тоже самое сделать в любом вашем языке

[10:17] 
у вас получится три четыре класса и куча проверок условий

[10:17] 
еще одна крутость в том что дерево полиморфное

[10:17] 
хранить в узлах вы можете любой тип(edited)

[10:17] 
Node a

[10:17] 
вот это называется конструктор типа(edited)

[10:17] 
конкретный тип может быть Node Integer

[10:17] 
Node String

[10:17] 
и так далее

densom [10:18 PM] 
У меня знакомый есть, он части спутников на микросхемах  собирал на Омском заводе в СССР. Дак он мне прямо в лицо сказал, не люблю я твое - "программирование", потому - что на микросхемах все надежно, а у тебя нет. До сих пор размышляю над его словами.

kirill.mokevnin [10:18 PM] 
```freeTree :: Tree Char  
freeTree =   
    Node 'P'  
        (Node 'O'  
            (Node 'L'  
                (Node 'N' Empty Empty)  
                (Node 'T' Empty Empty)  
            )  
            (Node 'Y'  
                (Node 'S' Empty Empty)  
                (Node 'A' Empty Empty)  
            )  
        )  
        (Node 'L'  
            (Node 'W'  
                (Node 'C' Empty Empty)  
                (Node 'R' Empty Empty)  
            )  
            (Node 'A'  
                (Node 'A' Empty Empty)  
                (Node 'C' Empty Empty)  
            )  
        )  

```

[10:18] 
вот пример собранного дерева

sashashakun [10:19 PM] 
Это вот про типы, получается с таким подходом мы имеем гибкость, данную конструкторами типов и надежность, как это правильно, «строгой» типизации?

alexelizarov [10:19 PM] 
А в хаскелле можно создавать собственные типы ведь? И это ни разу не классы будут? То есть важно, какие язык программирования предлагает возможности для создания типов?

kirill.mokevnin [10:19 PM] 
не строгой

[10:19] 
вот то что выше это и есть собственный тип

[10:19] 
его определение задает его же инварианты

[10:19] 
определение рекурсивно

[10:20] 
определение типа доказывает его же корректность

[10:20] 
это фактически математическое определение

[10:20] 
тут еще важно что в фп языках используются так называемые Алгебраические Типы Данных

[10:20] 
в общем все это строго красиво и математично

[10:20] 
и работает самое главное

alexelizarov [10:21 PM] 
А дальше там надо писать функции, которые работают с этим новым типом? И все, внутрь типа мы никак не залезем, без всяких private, да?

kirill.mokevnin [10:21 PM] 
зачем вам private?

[10:21] 
вы из чего исходите?)

[10:22] 
смотрите, на кастомный тип вы можете добавлять новые функции где угодно

[10:22] 
и сколько угодно

[10:22] 
что вам надо сделать чтобы расширить класс?

v.manenkov [10:22 PM] 
Я читал интервью с создателем хаскеля, который сейчас Microsoft Research работает. Он говорил, что иерархия типов данных как иерархия классов в объектном подходе. Что можно это всё это визуализировать и получится что-то типа UML  диаграммы.

kirill.mokevnin [10:22 PM] 
а довесить интерфейс?

alexelizarov [10:22 PM] 
вот я и говорю, без private) ну в Java надо было бы private написать что бы можно было с новым типом(классом) работать только через интерфейс

kirill.mokevnin [10:23 PM] 
кроме всего выше вы получили дополнительно две фичи

alexelizarov [10:23 PM] 
расширяемость?

[10:23] 
можно новый тип на основе этого определить?

kirill.mokevnin [10:24 PM] 
1) расширяемость да, вы можете любому типу довесить поведение

[10:25] 
что вы можете сделать в классовом подходе?

[10:25] 
наследоваться)

[10:25] 
но это плохой ход, если все наследоваться начнут

[10:25] 
и в целом это не работает

[10:26] 
2) в хаскеле есть понятие класс типов

[10:26] 
можно провести аналогию с интерфейсами

[10:26] 
вы делаете класс типов и называете его Equal

[10:26] 
(такой есть встроенный, но типа нет)

alexelizarov [10:27 PM] 
Я читал про проблему базового класса, в ней дело? Там про то что когда много уже унаследовано классов от твоего класса, причем другим программистами, ты боишься что то поменять уже в своем, базовом. Потому что это может порушить наследников

kirill.mokevnin [10:27 PM] 
так вот в любой момент любой тип может быть расширен классом типов

[10:27] 
вы можете сказать что ваши юзеры теперь Equal

[10:27] 
тоесть “сравнимые"

[10:27] 
и определяете для них функции которые требует класс типов Equal

[10:28] 
теперь сравните эти возможности с классическими классовыми возможностями

[10:28] 
земля и небо

alexelizarov [10:29 PM] 
почему земля и небо, не понимаю( действительно же на интерфейсы очень похоже

kirill.mokevnin [10:29 PM] 
как вы динамически интерфейс повесите на любой тип?

[10:29] 
а на встроенные типы?

[10:29] 
я уж не говорю про тотальное выведение типов

densom [10:30 PM] 
а mixin в ruby не похоже

kirill.mokevnin [10:31 PM] 
динамические языки вообще нельзя в этом смысле сравнивать, у вас нулевые гарантии

[10:31] 
добавил миксин и порушил весь код

[10:32] 
data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)

densom [10:32 PM] 
А какие проблемы будут склассами? Я не очень большой опыт в ООП имею, не могу сообразить

kirill.mokevnin [10:32 PM] 
определение собственного типа и подключение четырех классов типов

[10:33] 
я наверное не смог показать что надо думать не исходя из “инкапсуляция”, а других понятий(

[10:34] 
в общем изучайте то что ближе к computer science и математике, это формально и не подлежит холиварам, зная эти штуки все остальное вы будете понимать
1  

[10:34] 
где булшит, где нет

alexelizarov [10:35 PM] 
Я так понял что все вертится вокруг того, как мы строим типы данных? Если у языка мощная система типов, то наследование, например там вообще не сдалось

v.manenkov [10:36 PM] 
Вотдостаточно последоватльная статья по теме алгебраических типов данных http://fprog.ru/2009/issue2/roman-dushkin-algebraic-data-types/

[10:36] 
Давно тут рекомендовали журнал fprog.ru Это оттуда

kirill.mokevnin [10:36 PM] 
да, это клевая статья, роман душкин кстати в батл у нас даже пытался играть)

[10:37] 
но ушел потому что мы хаскель не добавили)

sashashakun [10:37 PM] 
@alexelizarov: а почему вы ищите что-то, вокруг чего все вертится? Я не думаю что есть некоторая точка, вокруг которой все решается

densom [10:37 PM] 
есть

alexelizarov [10:37 PM] 
@sashashakun: Нет, не то что одну точку ищу

[10:38] 
может их несколько. какие то базовые вещи, вокруг которых все вертится

[10:38] 
И вот стал задумываться что это не инкапсуляция, полиморфизм, наследование(edited)

v.manenkov [10:38 PM] 
alexelizarov: не нужно искать строгого соответствия в подходах объектном и функциональном. Можно у себя в голове сопоставлять, но нужно понимать, что строгого соответствия нет

alexelizarov [10:38 PM] 
Но что тогда)

sashashakun [10:39 PM] 
Я думаю это вопрос долгого самостоятельного изучения и анализа информации. Вряд ли так просто дать точные формулировки типа «инкапсуляция, полиморфизм, наследование»

kirill.mokevnin [10:39 PM] 
базовое в двух словах

[10:40] 
хотя подумал и понял что я еще не достиг дзена чтобы такое говорить :smile:

v.manenkov [10:40 PM] 
:smiley:

alexelizarov [10:40 PM] 
@sashashakun: я изучаю) полностью самостоятельно тоже сложно) слишком много вопросов появляется, и уже дальше материал плохо воспринимается, хочется немного разложить по местам) а спросить больше негде, я на экономическом учусь)

sashashakun [10:41 PM] 
Тогда добро пожаловать сюда)

alexelizarov [10:41 PM] 
Спасибо)

igrishaev [10:41 PM] 
Кстати, с чего все началось? Зачем функциям возвращать функции?

sashashakun [10:41 PM] 
Почитайте вот https://github.com/Hexlet/hexlet-slack-archive/wiki

GitHub
Hexlet/hexlet-slack-archive
hexlet-slack-archive - Архивы хороших бесед из Слака Хекслета

v.manenkov [10:42 PM] 
Всё началось с того, чем отличается абстракция от инкапсуляции. Эквивалентны ли понятия(edited)

densom [10:42 PM] 
он уже пол месяца здесь :simple_smile:

alexelizarov [10:43 PM] 
@sashashakun: некоторые уже по 3 раза перечитал. Когда понимал что не хватает знаний что бы понять лез на википедию, еще куда-нибудь. Но вопросов по-моему становилось все больше)

[10:43] 
@v.manenkov: нет нет, скорее эквивалентны ли понятия сокрытие реализации и инкапсуляция

kirill.mokevnin [10:45 PM] 
так кажется немного в голове уложилось

[10:45] 
выше я пример давал из хаскеля про тип данных

[10:45] 
вам в ооп нужно сокрытие для чего?

[10:46] 
я имею ввиду даже если у вас там внутри ничего скрытого

[10:46] 
а все данные прозрачны для клиента

[10:46] 
например user и его поля один в один из базы

densom [10:46 PM] 
чтобы реализовать модульность

v.manenkov [10:46 PM] 
Для контроля доступа

sashashakun [10:46 PM] 
переиспользование

alexelizarov [10:46 PM] 
что бы он не натворил чего)

kirill.mokevnin [10:46 PM] 
контроль доступа это не причина

[10:47] 
это следствие

[10:47] 
все остальное не туда)

[10:47] 
хотя “чтобы не на творил” ближе всего(edited)

[10:47] 
он нужен для поддержки инвариантов

[10:47] 
что у вас данные в согласованном виде

dstarcev [10:48 PM] 
чтобы нельзя было перевести в некорректное состояние

kirill.mokevnin [10:48 PM] 
типа сделал setName и fullName поменялся сразу же

alexelizarov [10:48 PM] 
а в примере выше мы так прописали что они не могут прийти в рассогласованное состояние?

kirill.mokevnin [10:49 PM] 
конкретно пример с деревом был такой да

[10:50] 
мы описали вид структуры и то как эти части друг с другом согласуются

densom [10:50 PM] 
и для любого их возможного состояния есть не падающая  обслуживающая функция?(edited)

alexelizarov [10:50 PM] 
и поэтому никакой контроль доступа нам там не нужен?

[10:51] 
в сикпе тоже самое когда рациональные числа строим на парах?

kirill.mokevnin [10:51 PM] 
я бы не сказал что он не нужен, просто идеально когда это перенесено на компилятор

v.manenkov [10:52 PM] 
Там хтирый алгоритм приведения типов, который всё автоматически проверяет. И в совокупности с классами типов это означает полный контроль. Я так понимаю. В результате обо всех ошибках узнаете на этапе компиляции и вынуждены их исправлять(edited)

kirill.mokevnin [10:52 PM] 
я знаю вот еще какую штуку, типы хаскеля при этом не на все способны

[10:53] 
и для того чтобы осуществлять гарантии на уровне всей программы (фактически программа и есть доказательство если скомпилировалась) нужны так называемые зависимые типы

[10:53] 
и в хаскеле их по дефолту нет

[10:53] 
но следующие поколения языков (после хаскеля в этом направлении) уже имеют такие типы

densom [10:54 PM] 
Подобное в ТурбоПаскале было в92 году. Создаешь свои типы. И компилируешь

sashashakun [10:54 PM] 
То есть при таком подходе если программа скомпилировалась, функционирование гарантировано? И нет варианта упасть?

kirill.mokevnin [10:54 PM] 
ну да, попробуй описать дерево в турбопаскале :wink:

[10:54] 
в теории да

[10:55] 
зависимые типы это когда не просто список char

[10:55] 
а вы можете сказать конкретно каких char

[10:55] 
и насколько мне известно, там большая проблема в том как их выразить на языках

[10:55] 
просто потому что нужно уметь описывать кучу всего

[10:56] 
посмотрите https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D1%8B%D0%B9_%D1%82%D0%B8%D0%BF

[10:56] 
Зависимый тип в информатике и логике — тип, который зависит от некоторого значения. Зависимые типы играют ключевую роль в интуиционистской теории типов[en] и построении функциональных языков программирования таких как ATS, Agda и Epigram.

v.manenkov [10:56 PM] 
sashashakun Если логических ошибок при проектировании не было, тодругих ошибок быть не может. Упасть варианта точно нет.(edited)

kirill.mokevnin [10:56 PM] 
https://ru.wikipedia.org/wiki/Agda

[10:56] 
Agda также является системой автоматического доказательства. Логические высказывания записываются как типы, а доказательствами являются программы соответствующего типа.

[10:57] 
о там пример натуральных чисел есть в вики

[10:57] 
ну и чтобы совсем мозг взорвать https://en.wikipedia.org/wiki/Coq

[10:57] 
In computer science, Coq is an interactive theorem prover. It allows the expression of mathematical assertions, mechanically checks proofs of these assertions, helps to find formal proofs, and extracts a certified program from the constructive proof of its formal specification. Coq works within the theory of the calculus of inductive constructions, a derivative of the calculus of constructions. Coq is not an automated theorem prover but includes automatic theorem proving tactics and various decision procedures.

[10:58] 
вот это все мне безумно интересно, но я чувствую себя глупой овцой когда смотрю на эти штуки)

[10:58] 
но планирую сюда нырять

[10:58] 
еще теорию категорий забыл)

[11:00] 
ну и если подвести итог, хотите чистого и не противоречивого в голове, учите хаскель

praytic [11:01 PM] 
=\

kirill.mokevnin [11:01 PM] 
ну кложу и так все учат, пора уже включать тяжелую артилерию

[11:01] 
мы тут начали понемногу закидываться

[11:01] 
щас кое что покажу)

[11:01] 
http://habrahabr.ru/company/hexlet/blog/248921/

Письмо Дейкстры: почему обучение программированию нужно начинать с функционального языка
Недавний перевод статьи «Пора заменить Python как язык для обучения» спровоцировал большую дискуссию. Очевидно, что программисты считают эту тему очень важной...

[11:02] 
В 2001 году, Эдсгер Дейкстра написал письмо экономическому совету университета Техаса. В нем знаменитый ученый призывает членов совета задуматься о смене языка программирования для вводного курса. К сожалению, язык был заменен на Java. Примерно в то же время MIT сменили язык курса «Структура и интерпретация компьютерных программ» с функционального Scheme (диалекта LISP) на Python.

Сегодня мы публикуем перевод этого письма.

Членам Экономического Совета

Я пишу вам по поводу слуха о замене языка во вводном курсе по программированию с функционального языка Haskell на императивный язык Java. Я считаю, что Совет должен взять на себя ответственность, чтобы решение не было принято на неправильном уровне.

densom [11:02 PM] 
А есть какая-нибуть книга , типа краткого введения в Haskel ?

[11:04] 
Кстати Дейкстра тоже писал о ненадежности программ высокого уровня, в отличие программ на микросхемах. Из за разных подходов к проектированию

v.manenkov [11:04 PM] 
Есть вот такое введение http://ohaskell.dshevchenko.biz/ru/index.html
О Haskell по-человечески. Книга о прекрасном и удивительном языке. Для обыкновенных программистов.

code4aman [11:05 PM] 
прям жесть пошла... помню нам зав. кафедры говорил, что когда они ездили в европу где-то в '05-'10 гг. им показывали ЯП, вроде разработка одного из немецких вузов, на котором любая программа в итоге это одно большое доказательство, которое если скомпилилось/было доказано, то баги исключены, код - почти математика, еще как-то со спецификациями это хитро связано, и мол такие программы используются в системах где риском является человеческая жизнь, название даже было какое-то

v.manenkov [11:06 PM] 
Agda и Coq: чуть выше про это написано
2  

code4aman [11:06 PM] 
там цель - спецификация -> готовый код, который генерится без человека (источника багов)

v.manenkov [11:07 PM] 
Вот спецификация-то как раз на типах

code4aman [11:09 PM] 
на зависимых типах да

densom [11:09 PM] 
При проектировании микросхемной логики - тоже логика и алгоритмы четкие

[11:10] 
таблицы всякие и с их преобразования, пока не получится конечный набор жестких микросхемных связей(edited)

[11:11] 
это я политех вспомнил

praytic [11:12 PM] 
> Примерно в то же время MIT сменили язык курса «Структура и интерпретация компьютерных программ» с функционального Scheme (диалекта LISP) на Python.
Я только сейчас понял, что этот ваш СИКП это учебник, к курсу 6.001 в MIT.(edited)

kirill.mokevnin [11:12 PM] 
http://www.clash-lang.org/
A landing page for information about the CλaSH HDL, a functional hardware description language

nazyrovrh [11:12 PM] 
фп мне нравиться, фп с его математикой намного ближе к реальной жизни чем императивное программирование НО эту реализацию надо же написать чтобы работало на silicon-e. тот же haskell написан на си как я понял

praytic [11:15 PM] 
кстати, на сайте MITа даже есть записи лекций по этому курсу
http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/

[11:15] 
старые правда

eye [11:27 PM] 
М... Программа-доказательство... Вижу проблему в таком рывке абстракции. Вот допустим есть у нас ассемблер - врубиться в него обычному человеку - проблема. Начали создавать языки более высокого уровня абстракции - ближе к человеку. Императивный совсем понятный, функциональный понятен если математикой заморочиться. Декларативный... Вот честно, об него проще всего голову сломать - давануть его в массы большая проблема, как я понимаю Agda и Coq еще замороченнее... Т.е. уровень абстракции как бы вырастает так быстро, что проносится мимо обычного человеческого уровня восприятия. При этом императивные языки все уменьшают порог вхождения. Т.е. лет через 30 каждый будет в состоянии написать программку на каком-нибудь питоне 5, а наследники Agda и Coq будут использоваться учеными и на особо требовательных к надежности участках?


----- January 21st -----
bahmurov [6:03 AM] 
joined #computer_science

code4aman [6:48 AM] 
Дело субъективное, я забил на математику, учил императивный язык, слыхал про логические и функциональные немного, переход хоть и был чуть болезненный, но я понял что не циклом единым, и если еще потерпеть - то и Agda/Coq можно осилить, тут больше надо теорию сначала подтянуть. Но я думаю что с нормальной базой человеку будет все равно с чего начать, переход подразумевает дискомфорт по-любому

thepry [7:31 AM] 
>Декларативный... Вот честно, об него проще всего голову сломать - давануть его в массы большая проблема

[7:32] 
Декларативность не противоречит понимаю. Декларативный код говорит, что нужно сделал, а императивный - как.

[7:34] 
Вот SQL - он декларативный и понятный. Например, ты пишешь, что мол выбери мне товары с ценой больше 100 долларов. Ты не пишешь как выбрать оптимальный индекс и обойти его, а потом вернуть тебе массив записей.

eye [10:10 AM] 
Видимо я понятия спутал. Имел ввиду пролог и подобные, т.е. логический, так? С одной стороны такие языки понять можно и они дают свои фишки, с другой стороны мой опыт императивного вообще никак не помогал понять, как работать с тем же прологом... И это на учебном задании, что там после основных возможностей начинается - боюсь представить.

obojdi [11:16 AM] 
joined #computer_science. Also, @teryaew joined.

code4aman [11:35 AM] 
Может вы пытались отправить электронное письмо в прологе, поэтому не пошло? :sweat_smile:

eye [11:46 AM] 
Не, нас мучили фамильным древом и подсчетом по какому-нибудь условию, типа среднего числа племянников на душу населения. И это очень удобно решалось прологом, но чтобы дойти, как этим пользоваться - мне пришлось ломать голову несколько суток. И знания императивного подхода скорее мешали все понять, нежели помогали. )(edited)

ssnpvl [12:24 PM] 
left #computer_science

deppkind [12:33 PM] 
@kirill.mokevnin: а ты хенгауты собираешь на такие свои “порционные выходы” полезной информации?

[12:34] 
просто меня тематика формального доказательства не только в рамках программирования, а систем в целом сильно интересует

[12:35] 
систем в реальной жизни - со стейкхолдерами, физикой сооружаемой системы и естественно ее назначения и архитектуры

kirill.mokevnin [12:36 PM] 
ничего такого не делаю

deppkind [12:39 PM] 
спс

deepq [4:45 PM] 
joined #computer_science. Also, @unaimillan joined.

unaimillan [8:17 PM] 
Привет

dmitriy.nesvitaylo [8:27 PM] 
@kirill.mokevnin:  День добрый! Кирилл, а почему писали курс основы программирования на php? Он лучше всего подходит? Почему не на хаскеле?

kirill.mokevnin [8:27 PM] 
Потому что задача обучать массовую аудиторию

[8:28] 
а человек который начитался в интернете про php и сайтостроительство, никогда в жизни не пойдет и не будет проходить курс непонятно на каком языке непонятно зачем(edited)

[8:28] 
поэтому план был под каждый язык сделать свою реализацию

[8:28] 
мы так и будем делать

dmitriy.nesvitaylo [8:28 PM] 
логично

[8:29] 
а там и до хаскеля доберёмся

kirill.mokevnin [8:29 PM] 
ну те кто более менее понимают, те заказывают сикп и проходят

[8:29] 
этот курс на лиспе в оригинале, что правильно

dmitriy.nesvitaylo [8:31 PM] 
читал последние сообщения, Вы там часто упоминали именно Хаскель..(edited)

[8:31] 
разница существенна между лисп языками?

[8:31] 
все это фп

kirill.mokevnin [8:31 PM] 
на уровне СИКП между лиспами разницы вообще нет

[8:31] 
хоть ракет хоть кложа

dmitriy.nesvitaylo [8:32 PM] 
всмысле между Хаскель и лиспом

kirill.mokevnin [8:32 PM] 
разница существенна

[8:32] 
лиспы это семейство языков

[8:32] 
главная особенность которых это гомоиконность

[8:32] 
это сильно отличает их от всего вообще

[8:32] 
и дает очень мощные возможности

[8:33] 
но лисп это не фп язык, на нем можно писать очень даже императивно

[8:33] 
просто по своей природе он тяготеет к функциональной парадигме и так на нем и пишут

dmitriy.nesvitaylo [8:34 PM] 
Ясно, спасибо!

[8:36] 
для начинающего веб-разраба нужен php, js, sql html, css набор? осталось только упорядочить как-то и системно учить

[8:37] 
незнаю с чего начать.. пхп вообще не учил, кроме курсов... джэс познания тоже на нач уровне

v.manenkov [8:37 PM] 
У Хекслета есть карта map.hexlet.io
1  

dmitriy.nesvitaylo [8:38 PM] 
да, знаю

[8:38] 
книженции тоже надо

[8:39] 
извините, офтоп

kirill.mokevnin [8:39 PM] 
мы сейчас в процессе формирования этих стеков на самом хекслете

[8:40] 
скоро будем прямо за руку вести сквозь все это дело

[8:40] 
ну а так начинайте по порядку как в мапе

[8:40] 
вам тут хватит чтобы сильно поднять свой уровень
5  


----- January 22nd -----
anatolean [12:17 AM] 
joined #computer_science

kirill.mokevnin [11:11 AM] 
ах красота https://www.dropbox.com/s/rqni9df6hon8trb/Screenshot%202016-01-22%2011.10.57.png?dl=0

kirill.mokevnin [11:11 AM] 
 shared an image: Screenshot 2016-01-22 11.10.57.png 
Add Comment
1  

igrishaev [11:14 AM] 
забавно, что примеры начинаются с такого

kirill.mokevnin [11:15 AM] 
там до этого еще довольно много вводной истории

someone [11:18 AM] 
это “во имя добра”?

sora [11:18 AM] 
Это откуда скрин? Новая статья?

kirill.mokevnin [11:18 AM] 
нет

[11:18] 
это набор статей по хаскелю с хабра

[11:19] 
очень прикольно написано

[11:19] 
теория категорий в 5 частях для тех кто ни бум бум в математике

[11:19] 
http://habrahabr.ru/post/245797/

Теория категорий для программистов: предисловие
Вот уже некоторое время я обдумываю идею написать книгу о теории категорий для программистов. Не компьютерных теоретиков, программистов — скорее инженеров, чем...

[11:19] 
это первая, а там дальше ссылки

andreydruzhinin [11:21 AM] 
спасибо за ссылку )

sora [11:23 AM] 
Спасибо!

kirill.mokevnin [11:26 AM] 
эх, вообще в нашем слаке есть денис шевченко, ссылки на книгу которого постоянно мелькают

[11:26] 
надо его вызывать как нибудь чтобы по хаскелю по рассказывал

[11:27] 
попробую ка с ним связаться

someone [11:29 AM] 
А вот какая ниша у хаскеля? Какого типа задачи лучше решать на нем? Я понимаю, что на нем можно наплодить абстракций самого высокого уровня, но когда это необходимо?

kirill.mokevnin [11:29 AM] 
да любая ниша, это язык общего назначения

igrishaev [11:29 AM] 
lets wiki says https://wiki.haskell.org/Haskell_in_industry

kirill.mokevnin [11:29 AM] 
на нем много чего пишут в совершенно разных и неожиданных местах

[11:30] 
хаскель является источником вдохновения всех языков, то что в нем было 20 лет назад, только сейчас появляется в других языках

[11:30] 
ну и самое все таки главное, хаскель это в первую очередь исследовательский язык вышедший из недр microsoft research

[11:31] 
полностью чистый язык

someone [11:31 AM] 
Читал одно мнение, что на хаскеле можно работать только в условиях конечного замороженного ТЗ, ибо малейшее изменение в нем приведет к каскаду переписывания типов

kirill.mokevnin [11:32 AM] 
а в java не приведет?

[11:32] 
естественно что если у вас от типа что то зависит, то оно будет переделано

[11:32] 
только у хаскеля есть а) по дефолту параметрический полиморфизм 2) выведение типов

[11:34] 
но с точки зрения опытных девелоперов, хаскель это просто источник вдохновения и дзена

[11:35] 
то есть к нему не стоит никогда относиться как “некуда применить не буду учить"

[11:35] 
хотите применить, пожалуйста ocaml

someone [11:36 AM] 
я ни разу такого не говорил :simple_smile:

kirill.mokevnin [11:36 AM] 
ну это я к слову)

[11:37] 
если говорить конкретно, а где лучше всего сработает хаскель, то это, например, написание своих собственных языков

[11:37] 
например elm написан на хаскеле

igrishaev [11:37 AM] 
pandoc, которым очень много кто пользуется

kirill.mokevnin [11:37 AM] 
мои товарищи из aviasales там же использовали хаскель

[11:37] 
хотя пишут на руби в основном (раньше)

[11:38] 
сейчас вроде на питоне там все

someone [11:38 AM] 
я с ним немного знаком, делал первую попытку изучить, книжку почитал, несколько упражнений, а-ля реализуйте тип бесконечного потока чисел, но потом отложил на некоторое время :simple_smile:

kirill.mokevnin [11:39 AM] 
да там все что до побочных эффектов приятно понятно и относительно просто

[11:39] 
для знакомых с фп

someone [11:40 AM] 
ну, собственно с него и началось моё знакомство с фп :simple_smile:

kirill.mokevnin [11:40 AM] 
короче с денисом договорился, через две недели в пятницу текстовый вебинар по хаскелю(edited)
5  

someone [11:40 AM] 
может быть поэтому знакомство с эрлангом прошло безболезненно :simple_smile:

k1s [11:40 AM] 
лучше не текстовый
5  

igrishaev [11:41 AM] 
Я Макса Крайнова читаю, вроде он часто про руби упоминает. С чего бы им на питон переходить

kirill.mokevnin [11:41 AM] 
это эксперимент, потом скажете что как

igrishaev [11:41 AM] 
шило на мыло имхо

kirill.mokevnin [11:41 AM] 
они много чего на питон перевели

leusmaximus [11:53 AM] 
@kirill.mokevnin: 
Это он?
http://dshevchenko.biz/
https://www.gitbook.com/book/dshevchenko_biz/ohaskell/details
GitBook
О Haskell по-человечески  - GitBook
О языке Haskell для обыкновенных программистов (5KB)
(edited)

kirill.mokevnin [11:55 AM] 
да

sashashakun [11:57 AM] 
О, он был в SDCast

[11:58] 
И в DevZen, как подсказывает гугл)

andrey_ash [11:58 AM] 
http://bananasandlenses.net/
1  

delaguardo [1:11 PM] 
в aviasales сейчас чего только нет) и ruby и python и elixir, и много чего еще, проще перечислить чего нет

[1:12] 
но вот хаскель пока нигде не использовали

dmitriy.nesvitaylo [1:13 PM] 
по поводу пустого множества - как оно может быть любым типом? если там ничего

kirill.mokevnin [1:15 PM] 
Использовал Антон Плешивцев, он даже с докладами на эту тему выступал

delaguardo [1:15 PM] 
clojure может? она есть, про хаскель не могу вспомнить)

kirill.mokevnin [1:15 PM] 
именно хаскель

[1:15] 
но очень вероятно что ее выпилили после него)

delaguardo [1:15 PM] 
хм, уточню

kirill.mokevnin [1:16 PM] 
эта штука отвечала за диспетчеризацию запросов на основе того что за пользователь

[1:16] 
от какого агента, из какой страны, кучи условий

[1:16] 
эту штуку постоянно тюнили и легко было сделать ошибки

[1:16] 
он написал небольшой dsl который позволял даже менеджерам описывать это дело (но не факт что они это делали)

[1:16] 
компилилось все это хаскелем

delaguardo [1:16 PM] 
вспомнил, было дело, но в прод так и не ушло

kirill.mokevnin [1:16 PM] 
вроде как успешно прошло продакшен испытания

[1:16] 
а, окей

[1:17] 
я так понимаю народ запереживал?)

delaguardo [1:18 PM] 
не, тут энтузиастов полно, подхватили бы, но на питоне оказадось проще сделать

igrishaev [1:21 PM] 
— Разве мир написан не на Лиспе”
— Ну, я торопился, поэтому быстренько накидал на Перле

[1:21] 
(с) Бог xkcd.com/224/(edited)
2  

kirill.mokevnin [1:24 PM] 
:smile:

endurance [1:41 PM] 
А из более-менее известных фирм/контор использует хаскель ?

[1:41] 
Кроме селектел

kirill.mokevnin [1:42 PM] 
много кто, но так же как и эрланг он обычно в нагрузку идет

kire [3:17 PM] 
joined #computer_science. Also, @graywrk joined.

alexelizarov [11:34 PM] 
uploaded and commented on an image: term.PNG 
1 Comment
Помогите пожалуйста, никак не могу понять что такое термы. Нашел вот такое определение. На самом деле много разных находил, но все одинаково непонятные

alexelizarov [11:35 PM] 
Я так понимаю что (MN) это применение M к N? Но сказано что M и N это термы. А термами могут быть простые переменные. Т.е M может быть переменной и N может быть переменной, правильно?(edited)

[11:35] 
тогда как можно применить переменную к другой переменной?

[11:36] 
я думал что только функцию можно к аргументам применить(edited)

sashashakun [11:38 PM] 
А можно ссылочку откуда скриншот?

alexelizarov [11:39 PM] 
https://anton-k.github.io/ru-haskell-book/book/14.html

[11:40] 
https://www.youtube.com/watch?v=7BPQ-gpXKt4&list=PLlb7e2G7aSpRDR44HMNqDHYgrAOPp7QLr&index=1 и еще в этом видео то же самое чувак говорит
YouTube
Computer Science Center
Лямбда-исчисление
 

[11:40] 
На википедии про какие-то индивидные константы, совсем не понимаю

kirill.mokevnin [11:41 PM] 
https://en.wikipedia.org/wiki/Term_(logic)

sashashakun [11:41 PM] 
>Комбинаторные термы (или просто «выражения»)
https://ru.wikibooks.org/wiki/%D0%9A%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%E2%80%94_%D1%8D%D1%82%D0%BE_%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE!

alexelizarov [11:46 PM] 
Спасибо, постараюсь английский вариант осилить)

kirill.mokevnin [11:46 PM] 
a term denotes a mathematical object

[11:47] 
A first-order term is recursively constructed from constant symbols, variables and function symbols.

dstarcev [11:48 PM] 
судя по статье, терм это неделимая (минимальная) часть выражения, а выражения строятся как деревья из термов

kirill.mokevnin [11:49 PM] 
ну там нет слова минимальная/неделимая, это просто мат объект выраженный комбинацией символов переменных и функциональных символов

dstarcev [11:50 PM] 
ну если составное выражение, это можно назвать термом?

kirill.mokevnin [11:50 PM] 
https://en.wikipedia.org/wiki/Uninterpreted_function по ссылке вот какая штука интересная

[11:50] 
да терм в том числе

[11:50] 
я просто на практике в эрланге постоянно с этим сталкивался

[11:50] 
очень часто тип определен как term()

[11:50] 
и дальше идет толкование

[11:50] 
что терм может быть a | b | c

[11:50] 
в свою очередь они тоже могут быть составными

[11:52] 
вот пример

[11:52] 
 ```delete(Elem, List1) -> List2

Types:

Elem = T
List1 = List2 = [T]
T = term()
Returns a copy of List1 where the first element matching Elem is deleted, if there is such an element.
```

dstarcev [11:53 PM] 
в данном случае это означает любой тип вообще

[11:53] 
в списке же все что угодно можно хранить

alexelizarov [11:53 PM] 
Т.е получается 2 - это терм, 2 + 3 - тоже терм, а 4*x, например? Это терм? Или это будет термом только в функции, в которой есть параметр x?

kirill.mokevnin [11:54 PM] 
https://en.wikipedia.org/wiki/Term_(logic) вот тут есть formal definition

alexelizarov [11:56 PM] 
получается что 2+3 не терм

dstarcev [11:57 PM] 
если + это функциональная константа, то терм

alexelizarov [11:58 PM] 
аа, + же можно как функцию рассмативать

[11:58] 
а условие это терм? Про условия ничего не сказано


----- January 23rd -----
teddyp1cker [12:00 AM] 
> всякая индивидная константа есть терм;
> всякая свободная переменная есть терм;
> если f^i — і-местная функциональная константа и t_1, t_2, …, t_i — термы, то f^i(t_1, t_2, ..., t_i) также есть терм.

[12:02] 
Что такое функциональная константа я не понял, "2", "3" - термы, F_1(t1, t2) = t1 + t2 - терм?

dstarcev [12:02 AM] 
да

[12:03] 
For example, (x+1)*(x+1) is a term built from the constant 1, the variable x, and the binary function symbols + and *

teddyp1cker [12:03 AM] 
ну тогда да пример выше - терм

[12:03] 
2+3

dstarcev [12:03 AM] 
да

[12:04] 
функциональная константа этьо наверное чистая функция

alexelizarov [12:04 AM] 
а с условием наверное получается if term1 then term2 else term3? Но может ли вся конструкция  if term1 then term2 else term3 в свою очередь рассматриваться как терм?

dstarcev [12:05 AM] 
я думаю что может) ничего не мешает

teddyp1cker [12:05 AM] 
если + - оператор

dstarcev [12:05 AM] 
это можно рассматривать как функцию F_3(t1,t2,t3)

teddyp1cker [12:05 AM] 
то почему бы и if не быть оператором

alexelizarov [12:06 AM] 
да, понял) получается что вообще все в нашей программе - это термы?

teddyp1cker [12:06 AM] 
термы это часть языка

[12:06] 
формального

alexelizarov [12:06 AM] 
ну да, хотелось бы понять как это на программирование переносится

[12:08] 
а, вот еще, вызов функции - это терм, а объявление? (define (square x) ( * x x)) тут только ( * x x) будет терм? Или все объявление функции - тоже терм?(edited)

dstarcev [12:10 AM] 
объявление функции это просто функция

[12:11] 
попадает под условие 3 формального определения

alexelizarov [12:12 AM] 
тогда не понятно под что вызов функции попадает)

praytic [12:13 AM] 
а зачем нужно знать такую ерунду?

dstarcev [12:13 AM] 
хотя в кложе я не знаю возвращает ли define функцию

densom [12:14 AM] 
а почему нет?

dstarcev [12:14 AM] 
там вроде если хочешь функцию вернуть нужно lambda использовать

[12:14] 
ты же не можешь (define (x) x*x) передать куда-то?

alexelizarov [12:15 AM] 
нет, получается не терм

[12:15] 
по третьему определению

dstarcev [12:15 AM] 
там правда (* x x) будет, но не суть

alexelizarov [12:17 AM] 
может тут вот в чем дело, термы же в лямбда-исчислении используются, а лямбда-исчисление - это про анонимные функции, поэтлму там определение функции - это терм

[12:18] 
хотя вообще не понял, а что это такое? (define (x) x*x)?

teddyp1cker [12:18 AM] 
> A first-order term is recursively constructed from constant symbols, variables and function symbols.
F_i - терм, F_j (c1, f1) = c1 * F_i(c1)) - содержит вызов терма (состоит из константы и функционального символа) -> вроде как терм

dstarcev [12:19 AM] 
(define (x) (* x x))

alexelizarov [12:19 AM] 
а где имя? Это так в кложе анонимная функция что ли объявляется?

teddyp1cker [12:19 AM] 
*первого порядка - видимо есть и другие

dstarcev [12:19 AM] 
да, я не знаю scheme))

[12:20] 
имя надо добавить

alexelizarov [12:20 AM] 
а, ну если мы имя добавляем то можно же передавать как аргумент

[12:20] 
В кложе же есть ФВП?

dstarcev [12:21 AM] 
`(define (square x) (* x x))` и `(lambda (x) (* x x))`(edited)

[12:21] 
второе передают и возвращают

[12:21] 
а первое объявляет просто(edited)

atosdo [12:22 AM] 
```(define square (lambda (x) (* x x)))```
(edited)

alexelizarov [12:23 AM] 
А в Scheme можно (define (square x) (* x x)) и саму square передать в качестве аргумента

[12:23] 
не обязательно лямбда

atosdo [12:23 AM] 
есс-но

dstarcev [12:24 AM] 
да, но ты не можешь при вызове функции написать define

atosdo [12:25 AM] 
да, так через lambda

[12:25] 
 ```((lambda (x) (* x x)) 5) ; = 25```
(edited)

alexelizarov [12:25 AM] 
да, это нельзя конечно. Но на вики и не говорится же ничего про вызов

dstarcev [12:26 AM] 
в императивных языках обычно разделяют выражения (expressions) и стейтменты( statement), так вот выражения могут вычисляться во что-то. а стейтменты просто что-то делают, но ничего не возвращают

teddyp1cker [12:26 AM] 
потому что там просто не понятия вызов

dstarcev [12:26 AM] 
так вот термы это очень похоже на выражения(edited)

alexelizarov [12:26 AM] 
Я так понял что если мы определяем какую то конструкцию, которую потом можем использовать в качестве аргумента ф-ии - то это терм

dstarcev [12:27 AM] 
или вернуть из функции

teddyp1cker [12:27 AM] 
вот выше пример
```((lambda (x) (* x x)) 5) ; = 25```
терм, причем содержит результат применения терма (функционального) к другому терму (константе)

[12:28] 
как я понял по определению это терм

dstarcev [12:28 AM] 
да

[12:28] 
и 25 тоже

[12:29] 
define получается  просто задает имя какому-то выражению

[12:29] 
терму

teddyp1cker [12:29 AM] 
потому в определении есть слово рекурсия :simple_smile:

alexelizarov [12:29 AM] 
Получается 2 - терм, x -терм, 2+x- терм . (define (square x) (* x x)) -тоже терм. И даже (+ (square 2) (square 3)) - терм. И если мы определим какую-нибудь ФВП - это тоже будет терм, и потом вызов этой ФВП с параметром square - тоже терм, ну и т.д

dstarcev [12:30 AM] 
(define (square x) (* x x))  это решили что не терм)

alexelizarov [12:30 AM] 
Да, понял что терм)

dstarcev [12:30 AM] 
:grinning:

alexelizarov [12:31 AM] 
Всем спасибо, понятнее стало)

[12:31] 
ой, не терм)

[12:31] 
не так прочитал опять)

[12:31] 
хм, а я понял что терм))

dstarcev [12:31 AM] 
ну ты не можешь эту конструкцию вернуть

[12:31] 
или передать

[12:32] 
ты можешь вернуть или передать square

[12:32] 
но не ее объявление

alexelizarov [12:34 AM] 
А define - это же вроде синтаксический сахар? на самом деле лямбда создается

[12:34] 
в сикпе так написано)

dstarcev [12:34 AM] 
define это присвоение имени какому-то терму

[12:34] 
лямбде или константе тоже можно

densom [12:35 AM] 
там помоему нет присвоений. связывание

alexelizarov [12:35 AM] 
понял наверное) я так понял, сама функция - это терм, но define - это не терм

[12:35] 
поправьте пожалуйста если не так

dstarcev [12:37 AM] 
ну да, это все импреативные термины)

[12:37] 
присваивание

alexelizarov [12:37 AM] 
На самом деле когда мы пишем (define (squaer x) ( * x x)) интерпретируется это как (define squaer (lambda (x) ( * x x))). Вот лямбда здесь - это терм, а define square - нет(edited)

[12:37] 
это мы просто имя терму дали

dstarcev [12:37 AM] 
я это понял так)

alexelizarov [12:38 AM] 
Думаю так и есть) Define это же особая форма, ее не было в Черчевом лямбда-исчислении, значит вряд ли она может быть лямбда-термом)

[12:38] 
все, кажется дошло, спасибо всем!

kirill.mokevnin [12:46 AM] 
в лиспе все есть выражение и все возвращает результат

dstarcev [12:47 AM] 
а что возвращает define?

kirill.mokevnin [12:48 AM] 
не знаю, это ведь не значит что тебе это понадобится

[12:48] 
define это форма с сайд эффектом

[12:50] 
кстати в лиспах понятие вызов очень относительное

[12:50] 
из за макросов

[12:50] 
defn  в кложе это макрос

dstarcev [12:51 AM] 
```(define (f1) (define x 3))
(write f1)

#<Closure> 
```

kirill.mokevnin [12:51 AM] 
возвращает саму лямбду?

dstarcev [12:52 AM] 
возможно, но я не смог ее вызвать и получить 3

kirill.mokevnin [12:54 AM] 
о кстати это логично, всегда же возвращается последнее выражение

[12:54] 
а внутри define  у тебя лямбда определяется

[12:54] 
вот она и возвращается

dstarcev [12:55 AM] 
```(define (f1) (define x x))
(write (f1 3)

#<undef>```

[12:57] 
 ```(define f1 (lambda x x))
(write (f1 3))

3```

[12:57] 
короче то что возвращает define никак нельзя вызвать, видимо это бесполезно

voldrun [3:53 AM] 
joined #computer_science


----- January 24th -----
k1s [11:44 AM] 
А какую книжку взять, чтобы самые основы нормально объяснялись и одно выводилось из другого с описанием структур данных и тд? Чтобы как Седжвик, только для ФП; единственная книга, где я(после быстрого просмотра десятка-полутора) встретил нормальное описание "вот у нас есть алгебраические типы данных которые могут то-то и для работы с ними у нас есть сопоставление с образцом так-то и так-то" это Real World Haskell(во всех остальных почему-то подобные вещи описываются отдельно друг от друга и понимания не происходит, как-то так). Может еще что-то фундаментальное есть? Чтобы и про деревья и про очереди всякие

dstarcev [12:03 PM] 
> Чтобы как Седжвик

[12:03] 
про какую книгу речь? Алгоритмы?

k1s [12:04 PM] 
да, там вообще все есть

dstarcev [12:05 PM] 
у него еще курсы есть хорошие. По ФП самому интересен ответ

k1s [12:06 PM] 
да, я проходил, курсы это неполная часть книги и удобнее ее перечитывать

[12:08] 
а по фп все книги которые я нашел ушли недалеко от сикпа, типа вот у нас пара, вот список на парах, но на самом деле это все деревья

jougene [1:12 PM] 
а кто может сказать вцратце - в 2 словах, чему все-таки учит SICP?

k1s [1:13 PM] 
расширению сознания

ihorbryk [1:13 PM] 
звучит как-то уж сильно круто :simple_smile:

k1s [1:18 PM] 
Про книжки – дело в том, что в скале ты в определенный момент замечаешь, что все структуры данных построены на case классах и видимо это не спроста, начинаешь гуглить, читаешь кучу статей, потом появляются слова "алгебраические типы данных", ты гуглишь это и тп и тд, продолжаешь что-то делать на скале и в определенный момент у тебя щелкает в голове и ты все понимаешь(по крайней мере создаешь какую-то картину происходящего), что все типы(не наследуемые от жажавы) в скале сделаны именно так, и что сопоставление с образцом это именно инструмент для работы с этим, и все вместе это составляет основу языка. А потом сразу возникает вопрос – почему ни в одной книге по скале не объясняется это все именно так, как это есть? А пишутся всякие штуки типа "ну это удобный способ для создания структур данных, а match это как switch в джаве но для классов перед которыми написано case". В том смысле, что все odersky style книги написаны как справочники для api, а описания фундаментальных вещей и как они все взаимосвязаны почему-то нет; посмотрел мельком хаскель во имя добра – там такая же фигня.

sashashakun [1:37 PM] 
@jougene: я книгу еще не читал, пока прохожу курс на хекслете. Из личного опыта: в определенный момент я понял что могу решить каждую задачу(на работе) более чем одним способом, и у каждого есть свои плюсы и минусы, и вот сикп говорит мне что действительно важно при выборе способа, а на что не нужно обращать внимание. Так же я вижу сикп как некую абстракцию над языками программирования, которые как известно, просто инструменты, и источник знания что важно, на что обращать внимание, а чего избегать. В общем я хотел бы прочитать всю книгу, но пока только в начале пути)

jougene [2:36 PM] 
@sashashakun: на каком месте курса вы находитесь?

sashashakun [3:07 PM] 
@jougene на 11 уроке

atosdo [3:52 PM] 
@k1s: может здесь что найдете 
http://alexott.net/ru/fp/books/

Знания нужно искать по крупицам и вместе самому соединять.
Все в одном месте и последовательно - нет, что на самом-то деле жаль.

cyril [4:06 PM] 
joined #computer_science. Also, @dmitriyabr joined.

atosdo [4:14 PM] 
Кто там хотел про типы, есть книга. 
http://newstar.rinet.ru/~goga/tapl/

ivanlemeshev [4:17 PM] 
@atosdo: спасибо!)

atosdo [4:18 PM] 
Выше ссылка - где куча литературы по ФП, что-то еще может понравиться. :wink:

denis.kozlov [5:25 PM] 
joined #computer_science. Also, @timadevelop joined, @poiuyt joined, @georgiybykov joined, @midler joined.


----- Yesterday January 25th, 2016 -----
kirill.mokevnin [10:14 AM] 
https://habrahabr.ru/post/204442/ для тех кто хочет больше

«Lisp in Small Pieces» на русском
Эта книга французского профессора Кристиана Кеннека об интерпретаторах Лиспа и Scheme довольно хорошо известна в англоязычном мире. Даже пару раз проскакивала...

alex_r [10:19 AM] 
может вы на сайте добавите еще один раздел для книг - не для тех что "на все времена", но и для просто хороших? :simple_smile:

[10:20] 
а то обидно когда здесь проскакивает что-то и исчезает в закладках, на глаза не попадается когда надо и ку-ку )

sashashakun [10:20 AM] 
>в русскоязычном сообществе Scheme чаще всего ассоциируется со «Структурой и интерпретацией компьютерных программ» (aka SICP). Это хороший учебник для новичков
>хороший учебник для новичков
>учебник для новичков
>для новичков
>новичков

[10:20] 
Просто хороших слишком много)

alex_r [10:20 AM] 
ну а что - СИКП же для первокурсников :simple_smile:

sashashakun [10:20 AM] 
Для первокурсников MIT)

alex_r [10:21 AM] 
можно подумать они в среднем умнее :simple_smile:

alexelizarov [10:28 AM] 
Объясните пожалуйста, в чем фундаментальность задачи об остановке? Только в том что удалось доказать, что существуют в принципе нерешаемые задачи? Я где-то слышал про проблему Гильберта кажется, что она формулировалась как то так "Существует ли алгоритм, который может решать все задачи из определенного класса задач" и вроде как Тьюринг ответил на этот вопрос отрицательно, доказав неразрешимость задачи об остановке.  Но как неразрешимость задачи об остановке доказывает отсутствие такого алгоритма?

alexelizarov [10:35 AM] 
Разве то, что решив задачу коммивояжера получится решить все задачи из класса NP нельзя рассматривать как общий алгоритм? не понимаю... что вообще значит общий алгоритм для решения класса задач?

alexelizarov [10:43 AM] 
И зачем вообще нужно изучать что то про машину Тьюринга? Я пока вижу только одну вещь, знания которой могут пригодиться - это Тьюринг полнота. Да и то, почти все языки сейчас Тьюринг-полные, кроме узкоспециализированных

[10:46] 
Да и с лямбда-исчислением не до конца понятно. Нашел несколько толстенных книжек про лямбда-исчисление, там во всех какая-то сложная теория, непонятные обозначения. Это все нужно знать программисту? Понятно, что анонимные функции, ФВП, каррирование - важные вещи. Но их же можно объяснить на программистском языке, без сложной теории лямбда-исчисления?

eye [10:48 AM] 
перед тем как появится что-то сложное на практике проходят годы теоретических размышлений, можно эту информацию считать экскурсом в историю, а можно затравкой к теоретическим изысканиям

igrishaev [10:48 AM] 
@alexelizarov: вы правы, можно ничего этого не изучать и работать программистом за хорошую зарплату

eye [10:48 AM] 
ну... программисту точно полезно будет знать общую концепцию, а насколько углубляться в теорию зависит от задач )

alexelizarov [10:49 AM] 
@igrishaev: хорошую зарплату... А быть хорошим программистом?

igrishaev [10:50 AM] 
зависит от критерия хорошести. вы можете решать задачи заказчика, не зная лямбда-исчислений

alexelizarov [10:53 AM] 
смотря как решать задачи)

[10:57] 
вот по-моему классная аналогия)

[10:57] 
В конце концов, когда мы ведём машину, то концентрируемся только на двух или трёх педалях, переключателе передач и руле. Для повседневной неспешной езды этого более чем достаточно. Однако, если мы хотим управлять автомобилем на пределе его возможностей, то тут нужно знать гораздо больше, чем просто три педали, КПП и руль.

Такой подход справедлив и в программировании. Большая часть повседневной мирской работы может быть выполнена при минимальном знании теории вычислительных систем или даже вообще без него. Не нужно понимать теорию категорий, чтобы накидать форму «Контакты» в PHP. Тем не менее, если вы планируете писать код, требующий серьёзных вычислений, то тут уж придётся разобраться с тем, что у этих самых вычислений под капотом.

[10:58] 
отсюда - https://habrahabr.ru/post/169373/

Основы теории вычислительных систем: машина с конечным числом состояний
Теория вычислительных систем — это то, что позволяет нам программировать. Однако, можно писать программы и без представление о концепциях, скрывающихся за...

igrishaev [10:58 AM] 
аналогия всегда ложна

sora [11:28 AM] 
Вот нашел еще интересную штуку для новичков - http://aliev.me/runestone/
An interactive version of Problem Solving with Algorithms and Data Structures using Python.

igrishaev [11:31 AM] 
тоже наброшу книжечку
http://www.books.ru/books/programmiruem-kollektivnyi-razum-586615/
Books.Ru – Книги: Программируем коллективный разум купить цена, заказ, оптом, отзывы, Сегаран, ISBN 5-93286-119-3, 0-596-52932-5, 978-5-93286-119-6
2  

[11:31] 
все примеры на Питоне, и автор очень серьезно подошел

[11:32] 
особенно глава про свой поисковик, очень подробно

sora [12:46 PM] 
Жаль пистон не знаю :disappointed: Осилю PHP может попробую изучить хоть поверху...

dstarcev [12:50 PM] 
Питон достаточно предсказуем для тех кто знает императивный язык типа PHP(edited)

[12:51] 
немного другой синтаксис и библиотечные функции, но смысл похожий

alex_r [12:56 PM] 
полистал книжку - дык это ж мегавещь!
а я о ней раньше вообще не слышал!

[12:57] 
(осилить бы до конца)

someone [1:00 PM] 
о, эволюционные вычисления

igrishaev [1:02 PM] 
книжка чем хороша — в ней не про питон, и сам язык почти не объясняется
только алгоритмы. метод опорных векторов, кластерная визуализация, обучение по байесу

sora [1:04 PM] 
Список непрочитанных книг неумолимо растет, где мои 50 часов в сутки! :sob:

[1:05] 
Вернуться на лет 5 назад, столько времени было!
5  

i.rastypain [1:05 PM] 
только вот осознания такого не было

sora [1:05 PM] 
Да, постоянно себя пилю за это!

vvalgis [1:06 PM] 
«Стартап про краткое изложение технических книг»

sora [1:06 PM] 
:simple_smile:

alex_r [1:06 PM] 
короткое изложение некоторых книг занимает столько же, сколько сами книги))

[1:06] 
как там это по-умному называется?

vvalgis [1:06 PM] 
Во многих ОЧЕНЬ много воды

v.manenkov [1:06 PM] 
Хабр?

alex_r [1:07 PM] 
насчёт воды - согласен, но иногда если без воды, то мозги перегреются)

vvalgis [1:08 PM] 
Вообще мне кажется, что формат последовательного изложения устарел. Быстрее воспринимать тех информацию в виде краткого изложения с возможностью углубится в детальное объяснение и примеры, если это необходимо.(edited)

alex_r [1:09 PM] 
Колмогоровская сложность

[1:09] 
"Колмогоровская сложность также известна как описательная сложность, сложность Колмогорова — Хайтина, стохастическая сложность, алгоритмическая энтропия или алгоритмическая сложность."

[1:09] 
:simple_smile:

[1:10] 
нашел в гугле по запросу "ab 32 раза" :simple_smile:

alexelizarov [1:32 PM] 
Объясните пожалуйста, в чем фундаментальность задачи об остановке? Только в том что удалось доказать, что существуют в принципе нерешаемые задачи? Я где-то слышал про проблему Гильберта кажется, что она формулировалась как то так "Существует ли алгоритм, который может решать все задачи из определенного класса задач" и вроде как Тьюринг ответил на этот вопрос отрицательно, доказав неразрешимость задачи об остановке.  Но как неразрешимость задачи об остановке доказывает отсутствие такого алгоритма?

[1:33] 
Разве то, что решив задачу коммивояжера получится решить все задачи из класса NP нельзя рассматривать как общий алгоритм? не понимаю... что вообще значит общий алгоритм для решения класса задач?

rakhim [1:34 PM] 
Не совсем понятно. Фундаментальность в том, что эта задача стала одной из основополагающих проблем новой на тот момент теории вычислимости

[1:35] 
Классы задач тут можно и не рассматривать

alexelizarov [1:35 PM] 
А в чем вот ее такая исключительная важность?

rakhim [1:35 PM] 
P vs NP это не про проблему остановки

[1:35] 
Важность в том, что она доказывает существование неразрешимых задач

alexelizarov [1:35 PM] 
А почему так важно было доказать их существование?

rakhim [1:36 PM] 
Когда придумали вычислительные машины, не было понятно есть ли у них лимит

[1:36] 
Ну вот перед вами задача

[1:36] 
Сложная, пока не понятно как решить

[1:36] 
А может ее вообще невозможно решить?

[1:36] 
Благодаря halting problem мы знаем что бывают такие задачи

[1:36] 
И возможно перед нами такая задача

alexelizarov [1:38 PM] 
А про проблему Гильберта и общий алгоритм это я что то путаю? Или была такая проблема? Я просто где то слышал давно, а вот после знакомства с машиной Тьюринга опять очень заинтересовала эта тема, а ссылку уже потерял(

rakhim [1:39 PM] 
Какую проблему? Их там вроде двадцатка

[1:39] 
там математика, топология, теория чисел

alexelizarov [1:40 PM] 
Действительно стоял вопрос о создании алгоритма, способного решать любую задачу из некоторого класса задач? Как такой алгоритм вообще возможен? Я смотрел статью про 23 задачи Гильберта, но там ее не было

v.manenkov [1:43 PM] 
P и NP связаны со сложностью алгоритмов. P-это задачи, которые можно решить за полиномиальное время. О большое от полинома. Не кажно какой он степени, просто принято считать что это легко разрешимые задачи

alexelizarov [1:44 PM] 
Да, это я знаю, а NP это которые можно решить за полиномиальное время, но только на недетерминированной машине Тьюринга

v.manenkov [1:44 PM] 
NP - это задачи для которых можно хотя бы просто быстро проверить решение (опять же за полиномиальное время )

[1:44] 
NP-полные это просто тупой перебор вариантов решения

[1:45] 
Получается экспонентациальное время, это больше чем полином. Порядок роста больше

[1:46] 
Вот эти задачи и решаются перебором

dstarcev [1:46 PM] 
NP-полная - это NP задача, к которой можно свести любую задачу из класса NP

[1:47] 
*за полиномиальное время

[1:47] 
но она все равно NP

v.manenkov [1:47 PM] 
не знаю причем там машина Тьюринга

dstarcev [1:48 PM] 
и не доказано что NP можно решить за полиномиальное время

alexelizarov [1:48 PM] 
Так у меня вопрос не про P, NP. Я знаю что это такое.

[1:48] 
Они просто там в контексте были

v.manenkov [1:51 PM] 
> Я где-то слышал про проблему Гильберта кажется, что она формулировалась как то так "Существует ли алгоритм, который может решать все задачи из определенного класса задач" и вроде как Тьюринг ответил на этот вопрос отрицательно, доказав неразрешимость задачи об остановке.
Я не видел конкретно этого доказательства неразрешимости остановки, сложно так судить

[1:52] 
Это всё про P ?= NP?(edited)

alexelizarov [1:53 PM] 
Все, я понял кажется. Существует же такая штука как универсальная машина Тьюринга. Которой на вход можно дать конкретную машину Тьюринга, входные данные и она даст выход. Если бы не существовало нерешаемых задач - то такая универсальная машина и была бы видимо тем самым общим алгоритмом. А Тьюринг доказал невозможность этого

[1:53] 
Не, P = NP? не об этом, я понял

[1:54] 
надеюсь понял)

alexelizarov [2:15 PM] 
если кому интересно, то вот в этой книге про универсальную машину Тьюринга написано.  http://www.ozon.ru/context/detail/id/5676581/ Там вообще про искусственный интеллелкт, но вторая глава вполне приземленная) и очень интересная)
Ozon.ru
Купить книгу «Новый ум короля. О компьютерах, мышлении и законах физики» автора Роджер Пенроуз и другие произведения в разделе Книги в интернет-магазине OZON.ru. Доступны цифровые, печатные и аудиокниги. На сайте вы можете почитать отзывы, рецензии, отрывки. Мы бесплатно доставим книгу «Новый ум короля. О компьютерах, мышлении и законах физики» по Москве при общей сумме заказа от 3000 рублей. Доставка по России от 49 рублей. Скидки и бонусы для постоянных покупателей.

george [3:57 PM] 
joined #computer_science

v.kolesnikov [4:09 PM] 
интересная програмка для изучающих sicp по scheme http://davidpilo.com/pvts/
4  

alexmold [4:16 PM] 
а как её установить?

v.kolesnikov [4:18 PM] 
@alexmold: PVTS is an executable JAR file and requires the Java Runtime Environment (JRE)

i.rastypain [4:19 PM] 
Для win есть .exe. В любом случае надо иметь на борту JVM

v.kolesnikov [4:21 PM] 
`java -jar PVTS.jar`

alexmold [4:54 PM] 
thx

andrey_ [5:01 PM] 
joined #computer_science

ignat [5:07 PM] 
Кто делал упражнения с 2.77 и далее? Расскажите, что использовали в качестве функций put и get

[5:09] 
А то в книжке какой-то неприятный момент: "put и get мы реализуем в третьей главе, а пока представьте что они уже есть"

v.kolesnikov [5:09 PM] 
)

[5:09] 
я не делал еще, через пару недель мб. там буду(edited)

ignat [5:13 PM] 
придется, видимо, пока придумывать какую-то замену

[5:14] 
а то код написал, а потестить нельзя


----- Today January 26th, 2016 -----
jougene [1:34 AM] 
просто закипает мозг, когда пытаюсь пройти урок №9 курса Основы Программирования

dstarcev [1:34 AM] 
скинь ссылку

jougene [1:36 AM] 
https://ru.hexlet.io/courses/php5/lessons/data/exercise_unit

[1:36] 
я опять считаю себя просто тупейшим ослов

[1:36] 
м

[1:36] 
я вообще не могу понять это все

dstarcev [1:41 AM] 
Ну давай по порядку. Что возвращает функция cons?

jougene [1:42 AM] 
она возвращает функцию, которая принимает на вход функцию

[1:42] 
которая в свою очередь принимает на вход два параметра

dstarcev [1:43 AM] 
И эти два параметра соответствуют тем, что были переданы в cons

jougene [1:43 AM] 
какой из двух выбрать мы должны обработать в двух дочерних функциях car и cdr

dstarcev [1:43 AM] 
car это первый элемент пары

[1:44] 
cdr второй

jougene [1:44 AM] 
да, это я все понял

[1:44] 
я щас просто совсем запутался, что кто принимает

[1:44] 
car cdr

[1:44] 
car принимает на вход функцию

[1:45] 
ой то есть пару

dstarcev [1:45 AM] 
Пара это функция

jougene [1:45 AM] 
да, лямбда функция которая на ходу создается

dstarcev [1:45 AM] 
И в этой функции внутри есть замыкание на x и y

[1:46] 
Т.е она о них знает

jougene [1:46 AM] 
ну да

[1:46] 
и что дальше

dstarcev [1:46 AM] 
car должна извлечь x из pair

jougene [1:46 AM] 
да

[1:46] 
return function($x, $y) use ($pair) {
       return $x;

[1:47] 
я думал надо сделать так

[1:47] 
но я по моему написал полную ахинею

dstarcev [1:47 AM] 
Результатов выполнения car должно быть значение

[1:47] 
А не функция

[1:48] 
pair позволяет передать в себя лямбду, которой даётся доступ к x и y

[1:49] 
Соответственно в случае с car тебе надо передать лямбду, которая выберет x

jougene [1:49 AM] 
я не понимаю

dstarcev [1:49 AM] 
Ну ты понял, что тебе надо вызвать функцию pair?

jougene [1:49 AM] 
ну без этого никак

dstarcev [1:50 AM] 
Что ты можешь передать в качестве аргумента туда?

jougene [1:50 AM] 
должен функцию

dstarcev [1:52 AM] 
Ок, что pair будет делать с функцией которую ты передал ей?(edited)

jougene [1:54 AM] 
я сделал задание

[1:54] 
но все равно не понял

[1:54] 
return $pair (function($x, $y) {return $x;});

[1:54] 
я написал вот так

[1:55] 
:grimacing:

[1:56] 
ну в cdr соответственно return $y

[1:57] 
курс как поверхностно затрагивает каждую тему из СИКП

[1:58] 
и даже не пойму где будет понятней

[1:58] 
пары там это вроде вообще уже вторая глава

[1:58] 
ну курс спасает от многого из математики - там матрицы с числами фиббоначчи

[1:59] 
интегралы методом симпсона

dstarcev [2:00 AM] 
Я сам не читал ещё

atosdo [2:04 AM] 
ну там да, немного необычно сделано, как для обычного человека.
смысл просто проследить, что куда передается, вот.

после cons возвращается анонимная функция, которая замыкает в себе x, y (хранит внутри)
а далее она передается в car, cdr и там уже извлекаться, что надо - первый аргумент или 2й.

:simple_smile:

atosdo [2:27 AM] 
Я вот открыл книгу Бертрана Мейерса - Почувствуй Класс - вообще ничего не понятно :simple_smile:
После СИКП - она кажется еще сложнее)))

v.kolesnikov [2:46 AM] 
имхо, в sicp нет "много математики", там как раз наглядно показывается, как можно представить математические абстракции (формулы, уравнения) в виде других абстракций, которые легко и привычно "программироать". Вот только сегодня делал упражнение 2.34 "Вычисление многочлена n-ной степени по схеме Горнера". Суть - представить выражение в виде списка аргументов и накопить их через accumulate (он же reduce, он же fold). Не надо ничего считать - вычитать и умножать, просто нужно повернуть свой мозг в такую точку, откуда ты можешь видеть что-то ( в данном случае - математические выражения и другие абстракции) в некотором "другом" виде, в частности в виде последовательностей как ​*универсальных интерфейсов*​, там кстати так прямо один из разделов и называется.(edited)

v.kolesnikov [2:52 AM] 
И ещё, для того чтобы как раз "повернуть свой мозг" таким образом, как раз и нужно делать как можно больше упражнений. Ведь что получается если вам кажется что упражнение сложное и вы его откладываете, проходите мимо - получается, что вы даже не знаете что в нём сокрыта за проблема и какие подходы можно применить к её решению, вы таким образом теряете довольно много. Гораздо лучше на мой взгляд, если даже смотря на задачу вы непонимаете ​*ничего*​, всё равно попробовать 1) внимательно вдуматься\вчитаться в задачу, постараться понять саму "проблему" задачи. 2) если ничего не понятно - лучше поискать эту задачу в учебниках\сети и изучить её решение, 3) закрепить понимание задачи и её решения в своем сознании, тут только один способ - практика, запрограммируйте задачу, поиграйтесь с запуском задачи с разными аргументами, ещё как вариант я довольно часто расписываю поведение програмы при некоторых аргументах прямо поэтапно на бумаге (схема подстановки) - это окончательно закрепляет в мозгу понимание того как работает абстракция.(edited)

[2:54] 
итого - решив таким образом "сложную" на первый взгляд задачу, вы совершите большое продвижение вперед, ведь вы станете ​*реально*​ умнее на 1 задачу, а может быть сразу на целый класс задач. если пройдете мимо - не приобретёте ничего...(edited)
3 4 3  

jougene [1:11 PM] 
у меня вопрос по 11 урока из Основ программирования

[1:11] 
по функции length

[1:11] 
правильно ли я понял, что для того чтоб посчитать длину списка, нам нужно проверить условие, что cdr($items) = null

[1:12] 
и если оно не выполняется, то мы вызываем рекурсивно функцию, куда вместо $items передаем cdr($items) и к результату return прибавляем единицу

jougene [1:13 PM] 
added a Plain Text snippet 
if  (cdr($items) == null) {
        return 0;
    } else {
        return 1 + length(cdr($items));
    }
Add Comment
kirill.mokevnin [1:16 PM] 
оно работает?)

jougene [1:16 PM] 
нет, не совсем

[1:16] 
не досчитывает одну единицу

[1:16] 
ну я на бумаге расписал как все вызывается и понял, что это не совсем верно

[1:17] 
ведь если список будет list(3, null) то у меня возвращается ноль

[1:17] 
а длина такого списка получается равна единице ведь

kirill.mokevnin [1:17 PM] 
ну так напиши return 1 где cdr проверка на null

jougene [1:18 PM] 
ну я так писал, он даже тест не стал проходить, потому что у меня пока функции остальные не рализованы

[1:18] 
ну и плюс в тесте в самом проверяется что должно вернуть 0

[1:18] 
если список пусток

[1:19] 
й

kirill.mokevnin [1:19 PM] 
на самом деле 0 у тебя в том случае когда $items == null

[1:19] 
а не cdr($items) == null

jougene [1:19 PM] 
я уже щас еще одно условие пишу

jougene [1:19 PM] 
added a Plain Text snippet 
if ($items == null) {
        return 0;
    } else {
        if  (cdr($items) == null) {
            return 1;
Add Comment Click to expand inline 9 lines
jougene [1:21 PM] 
одновременно с тем как вы написали я это понял
